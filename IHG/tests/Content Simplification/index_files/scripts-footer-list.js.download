/******************************************************************************
 * jquery.i18n.properties
 * 
 * Dual licensed under the GPL (http://dev.jquery.com/browser/trunk/jquery/GPL-LICENSE.txt) and 
 * MIT (http://dev.jquery.com/browser/trunk/jquery/MIT-LICENSE.txt) licenses.
 * 
 * @version     1.0.x
 * @author      Nuno Fernandes
 * @url         www.codingwithcoffee.com
 * @inspiration Localisation assistance for jQuery (http://keith-wood.name/localisation.html)
 *              by Keith Wood (kbwood{at}iinet.com.au) June 2007
 * 
 *****************************************************************************/

(function($) {
$.i18n = {};

/** Map holding bundle keys (if mode: 'map') */
$.i18n.map = {};
    
/**
 * Load and parse message bundle files (.properties),
 * making bundles keys available as javascript variables.
 * 
 * i18n files are named <name>.js, or <name>_<language>.js or <name>_<language>_<country>.js
 * Where:
 *      The <language> argument is a valid ISO Language Code. These codes are the lower-case, 
 *      two-letter codes as defined by ISO-639. You can find a full list of these codes at a 
 *      number of sites, such as: http://www.loc.gov/standards/iso639-2/englangn.html
 *      The <country> argument is a valid ISO Country Code. These codes are the upper-case,
 *      two-letter codes as defined by ISO-3166. You can find a full list of these codes at a
 *      number of sites, such as: http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html
 * 
 * Sample usage for a bundles/Messages.properties bundle:
 * $.i18n.properties({
 *      name:      'Messages', 
 *      language:  'en_US',
 *      path:      'bundles'
 * });
 * @param  name			(string/string[], optional) names of file to load (eg, 'Messages' or ['Msg1','Msg2']). Defaults to "Messages"
 * @param  language		(string, optional) language/country code (eg, 'en', 'en_US', 'pt_PT'). if not specified, language reported by the browser will be used instead.
 * @param  path			(string, optional) path of directory that contains file to load
 * @param  mode			(string, optional) whether bundles keys are available as JavaScript variables/functions or as a map (eg, 'vars' or 'map')
 * @param  cache        (boolean, optional) whether bundles should be cached by the browser, or forcibly reloaded on each page load. Defaults to false (i.e. forcibly reloaded)
 * @param  encoding 	(string, optional) the encoding to request for bundles. Property file resource bundles are specified to be in ISO-8859-1 format. Defaults to UTF-8 for backward compatibility.
 * @param  callback     (function, optional) callback function to be called after script is terminated
 */
$.i18n.properties = function(settings) {
	// set up settings
    var defaults = {
        name:           'Messages',
        language:       '',
        path:           '',  
        mode:           'vars',
        cache:			false,
        encoding:       'UTF-8',
        callback:       null
    };
    settings = $.extend(defaults, settings);    
    if(settings.language === null || settings.language == '') {
	   settings.language = $.i18n.browserLang();
	}
	if(settings.language === null) {settings.language='';}
	
	// load and parse bundle files
	var files = getFiles(settings.name);
	for(i=0; i<files.length; i++) {
		// 1. load base (eg, Messages.properties)
//		loadAndParseFile(settings.path + files[i] + '.properties', settings);
        // 2. with language code (eg, Messages_pt.properties)
//		if(settings.language.length >= 2) {
//            loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 2) +'.properties', settings);
//		}
		// 3. with language code and country code (eg, Messages_pt_PT.properties)
        if(settings.language.length >= 5) {
            loadAndParseFile(settings.path + files[i] + '_' + settings.language.substring(0, 5) +'.properties', settings);
        }
	}
	
	// call callback
	if(settings.callback){ settings.callback(); }
};


/**
 * When configured with mode: 'map', allows access to bundle values by specifying its key.
 * Eg, jQuery.i18n.prop('com.company.bundles.menu_add')
 */
$.i18n.prop = function(key /* Add parameters as function arguments as necessary  */) {
	var value = $.i18n.map[key];
	if (value == null)
		return '[' + key + ']';
	
//	if(arguments.length < 2) // No arguments.
//    //if(key == 'spv.lbl.modified') {alert(value);}
//		return value;
	
//	if (!$.isArray(placeHolderValues)) {
//		// If placeHolderValues is not an array, make it into one.
//		placeHolderValues = [placeHolderValues];
//		for (var i=2; i<arguments.length; i++)
//			placeHolderValues.push(arguments[i]);
//	}

	// Place holder replacement
	/**
	 * Tested with:
	 *   test.t1=asdf ''{0}''
	 *   test.t2=asdf '{0}' '{1}'{1}'zxcv
	 *   test.t3=This is \"a quote" 'a''{0}''s'd{fgh{ij'
	 *   test.t4="'''{'0}''" {0}{a}
	 *   test.t5="'''{0}'''" {1}
	 *   test.t6=a {1} b {0} c
	 *   test.t7=a 'quoted \\ s\ttringy' \t\t x
	 *
	 * Produces:
	 *   test.t1, p1 ==> asdf 'p1'
	 *   test.t2, p1 ==> asdf {0} {1}{1}zxcv
	 *   test.t3, p1 ==> This is "a quote" a'{0}'sd{fgh{ij
	 *   test.t4, p1 ==> "'{0}'" p1{a}
	 *   test.t5, p1 ==> "'{0}'" {1}
	 *   test.t6, p1 ==> a {1} b p1 c
	 *   test.t6, p1, p2 ==> a p2 b p1 c
	 *   test.t6, p1, p2, p3 ==> a p2 b p1 c
	 *   test.t7 ==> a quoted \ s	tringy 		 x
	 */
	
	var i;
	if (typeof(value) == 'string') {
        // Handle escape characters. Done separately from the tokenizing loop below because escape characters are 
		// active in quoted strings.
        i = 0;
        while ((i = value.indexOf('\\', i)) != -1) {
 		   if (value[i+1] == 't')
 			   value = value.substring(0, i) + '\t' + value.substring((i++) + 2); // tab
 		   else if (value[i+1] == 'r')
 			   value = value.substring(0, i) + '\r' + value.substring((i++) + 2); // return
 		   else if (value[i+1] == 'n')
 			   value = value.substring(0, i) + '\n' + value.substring((i++) + 2); // line feed
 		   else if (value[i+1] == 'f')
 			   value = value.substring(0, i) + '\f' + value.substring((i++) + 2); // form feed
 		   else if (value[i+1] == '\\')
 			   value = value.substring(0, i) + '\\' + value.substring((i++) + 2); // \
 		   else
 			   value = value.substring(0, i) + value.substring(i+1); // Quietly drop the character
        }
		
		// Lazily convert the string to a list of tokens.
		var arr = [], j, index;
		i = 0;
		while (i < value.length) {
			if (value[i] == '\'') {
				// Handle quotes
				if (i == value.length-1)
					value = value.substring(0, i); // Silently drop the trailing quote
				else if (value[i+1] == '\'')
					value = value.substring(0, i) + value.substring(++i); // Escaped quote
				else {
					// Quoted string
					j = i + 2;
					while ((j = value.indexOf('\'', j)) != -1) {
						if (j == value.length-1 || value[j+1] != '\'') {
							// Found start and end quotes. Remove them
							value = value.substring(0,i) + value.substring(i+1, j) + value.substring(j+1);
							i = j - 1;
							break;
						}
						else {
							// Found a double quote, reduce to a single quote.
							value = value.substring(0,j) + value.substring(++j);
						}
					}
					
					if (j == -1) {
						// There is no end quote. Drop the start quote
						value = value.substring(0,i) + value.substring(i+1);
					}
				}
			}
			else if (value[i] == '{') {
				// Beginning of an unquoted place holder.
				j = value.indexOf('}', i+1);
				if (j == -1)
					i++; // No end. Process the rest of the line. Java would throw an exception
				else {
					// Add 1 to the index so that it aligns with the function arguments.
					index = parseInt(value.substring(i+1, j));
					if (!isNaN(index) && index >= 0) {
						// Put the line thus far (if it isn't empty) into the array
						var s = value.substring(0, i);
						if (s != "")
							arr.push(s);
						// Put the parameter reference into the array
						arr.push(index);
						// Start the processing over again starting from the rest of the line.
						i = 0;
						value = value.substring(j+1);
					}
					else
						i = j + 1; // Invalid parameter. Leave as is.
				}
			}
			else
				i++;
		}
		
		// Put the remainder of the no-empty line into the array.
		if (value != "")
			arr.push(value);
		value = arr;
		
		// Make the array the value for the entry.
		$.i18n.map[key] = arr;
	}
	
	if (value.length == 0)
		return "";
	if (value.lengh == 1 && typeof(value[0]) == "string")
		return value[0];
	
	var s = "";
	for (i=0; i<value.length; i++) {
		if (typeof(value[i]) == "string")
			s += value[i];
		// Must be a number
		else if (value[i] + 1 < arguments.length)
			s += arguments[value[i] + 1];
		else
			s += "{"+ value[i] +"}";
	}
	
	return s;
};

/** Language reported by browser, normalized code */
$.i18n.browserLang = function() {
	return normaliseLanguageCode(navigator.language /* Mozilla */ || navigator.userLanguage /* IE */);
}


/** Load and parse .properties files */
function loadAndParseFile(filename, settings) {
	$.ajax({
        url:        filename,
        async:      false,
        cache:		settings.cache,
        contentType:'text/plain;charset='+ settings.encoding,
        dataType:   'text',
        success:    function(data, status) {
        				parseData(data, settings.mode); 
					}
    });
}

/** Parse .properties files */
function parseData(data, mode) {
   var parsed = '';
   var parameters = data.split( /\n/ );
   var regPlaceHolder = /(\{\d+\})/g;
   var regRepPlaceHolder = /\{(\d+)\}/g;
   var unicodeRE = /(\\u.{4})/ig;
   for(var i=0; i<parameters.length; i++ ) {
       parameters[i] = parameters[i].replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
       if(parameters[i].length > 0 && parameters[i].match("^#")!="#") { // skip comments
           var pair = parameters[i].split('=');
           if(pair.length > 0) {
               /** Process key & value */
               var name = unescape(pair[0]).replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
               var value = pair.length == 1 ? "" : pair[1];
               // process multi-line values
               while(value.match(/\\$/)=="\\") {
               		value = value.substring(0, value.length - 1);
               		value += parameters[++i].replace( /\s\s*$/, '' ); // right trim
               }               
               // Put values with embedded '='s back together
               for(var s=2;s<pair.length;s++){ value +='=' + pair[s]; }
               value = value.replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' ); // trim
               
               /** Mode: bundle keys in a map */
               if(mode == 'map' || mode == 'both') {
                   // handle unicode chars possibly left out
                   var unicodeMatches = value.match(unicodeRE);
                   if(unicodeMatches) {
                     for(var u=0; u<unicodeMatches.length; u++) {
                        value = value.replace( unicodeMatches[u], unescapeUnicode(unicodeMatches[u]));
                     }
                   }
                   // add to map
                   $.i18n.map[name] = value;
               }
               
               /** Mode: bundle keys as vars/functions */
               if(mode == 'vars' || mode == 'both') {
                   value = value.replace( /"/g, '\\"' ); // escape quotation mark (")
                   
                   // make sure namespaced key exists (eg, 'some.key') 
                   checkKeyNamespace(name);
                   
                   // value with variable substitutions
                   if(regPlaceHolder.test(value)) {
                       var parts = value.split(regPlaceHolder);
                       // process function args
                       var first = true;
                       var fnArgs = '';
                       var usedArgs = [];
                       for(var p=0; p<parts.length; p++) {
                           if(regPlaceHolder.test(parts[p]) && (usedArgs.length == 0 || usedArgs.indexOf(parts[p]) == -1)) {
                               if(!first) {fnArgs += ',';}
                               fnArgs += parts[p].replace(regRepPlaceHolder, 'v$1');
                               usedArgs.push(parts[p]);
                               first = false;
                           }
                       }
                       parsed += name + '=function(' + fnArgs + '){';
                       // process function body
                       var fnExpr = '"' + value.replace(regRepPlaceHolder, '"+v$1+"') + '"';
                       parsed += 'return ' + fnExpr + ';' + '};';
                       
                   // simple value
                   }else{
                       parsed += name+'="'+value+'";';
                   }
               } // END: Mode: bundle keys as vars/functions
           } // END: if(pair.length > 0)
       } // END: skip comments
   }
   eval(parsed);
}

/** Make sure namespace exists (for keys with dots in name) */
// TODO key parts that start with numbers quietly fail. i.e. month.short.1=Jan
function checkKeyNamespace(key) {
	var regDot = /\./;
	if(regDot.test(key)) {
		var fullname = '';
		var names = key.split( /\./ );
		for(var i=0; i<names.length; i++) {
			if(i>0) {fullname += '.';}
			fullname += names[i];
			if(eval('typeof '+fullname+' == "undefined"')) {
				eval(fullname + '={};');
			}
		}
	}
}

/** Make sure filename is an array */
function getFiles(names) {
	return (names && names.constructor == Array) ? names : [names];
}

/** Ensure language code is in the format aa_AA. */
function normaliseLanguageCode(lang) {
    lang = lang.toLowerCase();
    if(lang.length > 3) {
        lang = lang.substring(0, 3) + lang.substring(3).toUpperCase();
    }
    return lang;
}

/** Unescape unicode chars ('\u00e3') */
function unescapeUnicode(str) {
  // unescape unicode codes
  var codes = [];
  var code = parseInt(str.substr(2), 16);
  if (code >= 0 && code < Math.pow(2, 16)) {
     codes.push(code);
  }
  // convert codes to text
  var unescaped = '';
  for (var i = 0; i < codes.length; ++i) {
    unescaped += String.fromCharCode(codes[i]);
  }
  return unescaped;
}

/* Cross-Browser Split 1.0.1
(c) Steven Levithan <stevenlevithan.com>; MIT License
An ECMA-compliant, uniform cross-browser split method */
var cbSplit;
// avoid running twice, which would break `cbSplit._nativeSplit`'s reference to the native `split`
if (!cbSplit) {    
  cbSplit = function(str, separator, limit) {
      // if `separator` is not a regex, use the native `split`
      if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
        if(typeof cbSplit._nativeSplit == "undefined")
          return str.split(separator, limit);
        else
          return cbSplit._nativeSplit.call(str, separator, limit);
      }
  
      var output = [],
          lastLastIndex = 0,
          flags = (separator.ignoreCase ? "i" : "") +
                  (separator.multiline  ? "m" : "") +
                  (separator.sticky     ? "y" : ""),
          separator = RegExp(separator.source, flags + "g"), // make `global` and avoid `lastIndex` issues by working with a copy
          separator2, match, lastIndex, lastLength;
  
      str = str + ""; // type conversion
      if (!cbSplit._compliantExecNpcg) {
          separator2 = RegExp("^" + separator.source + "$(?!\\s)", flags); // doesn't need /g or /y, but they don't hurt
      }
  
      /* behavior for `limit`: if it's...
      - `undefined`: no limit.
      - `NaN` or zero: return an empty array.
      - a positive number: use `Math.floor(limit)`.
      - a negative number: no limit.
      - other: type-convert, then use the above rules. */
      if (limit === undefined || +limit < 0) {
          limit = Infinity;
      } else {
          limit = Math.floor(+limit);
          if (!limit) {
              return [];
          }
      }
  
      while (match = separator.exec(str)) {
          lastIndex = match.index + match[0].length; // `separator.lastIndex` is not reliable cross-browser
  
          if (lastIndex > lastLastIndex) {
              output.push(str.slice(lastLastIndex, match.index));
  
              // fix browsers whose `exec` methods don't consistently return `undefined` for nonparticipating capturing groups
              if (!cbSplit._compliantExecNpcg && match.length > 1) {
                  match[0].replace(separator2, function () {
                      for (var i = 1; i < arguments.length - 2; i++) {
                          if (arguments[i] === undefined) {
                              match[i] = undefined;
                          }
                      }
                  });
              }
  
              if (match.length > 1 && match.index < str.length) {
                  Array.prototype.push.apply(output, match.slice(1));
              }
  
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
  
              if (output.length >= limit) {
                  break;
              }
          }
  
          if (separator.lastIndex === match.index) {
              separator.lastIndex++; // avoid an infinite loop
          }
      }
  
      if (lastLastIndex === str.length) {
          if (lastLength || !separator.test("")) {
              output.push("");
          }
      } else {
          output.push(str.slice(lastLastIndex));
      }
  
      return output.length > limit ? output.slice(0, limit) : output;
  };
  
  cbSplit._compliantExecNpcg = /()??/.exec("")[1] === undefined; // NPCG: nonparticipating capturing group
  cbSplit._nativeSplit = String.prototype.split;

} // end `if (!cbSplit)`
String.prototype.split = function (separator, limit) {
    return cbSplit(this, separator, limit);
};

})(jQuery);
                /*!
 * jQuery Cookie Plugin v1.4.0
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as anonymous module.
		define(['jquery'], factory);
	} else {
		// Browser globals.
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
		} catch(e) {
			return;
		}

		try {
			// If we can't parse the cookie, ignore it, it's unusable.
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write
		if (value !== undefined && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setDate(t.getDate() + days);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) !== undefined) {
			// Must not alter options, thus extending a fresh object...
			$.cookie(key, '', $.extend({}, options, { expires: -1 }));
			return true;
		}
		return false;
	};

}));
/*!
 * Bootstrap v3.3.1 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.1",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.1",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")&&(c.prop("checked")&&this.$element.hasClass("active")?a=!1:b.find(".active").removeClass("active")),a&&c.prop("checked",!this.$element.hasClass("active")).trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active"));a&&this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=this.sliding=this.interval=this.$active=this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.1",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c="prev"==a?-1:1,d=this.getItemIndex(b),e=(d+c)%this.$items.length;return this.$items.eq(e)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i="next"==b?"first":"last",j=this;if(!f.length){if(!this.options.wrap)return;f=this.$element.find(".item")[i]()}if(f.hasClass("active"))return this.sliding=!1;var k=f[0],l=a.Event("slide.bs.carousel",{relatedTarget:k,direction:h});if(this.$element.trigger(l),!l.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var m=a(this.$indicators.children()[this.getItemIndex(f)]);m&&m.addClass("active")}var n=a.Event("slid.bs.carousel",{relatedTarget:k,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),j.sliding=!1,setTimeout(function(){j.$element.trigger(n)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(n)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&"show"==b&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a(this.options.trigger).filter('[href="#'+b.id+'"], [data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.1",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0,trigger:'[data-toggle="collapse"]'},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.find("> .panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":a.extend({},e.data(),{trigger:this});c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){b&&3===b.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=c(d),f={relatedTarget:this};e.hasClass("open")&&(e.trigger(b=a.Event("hide.bs.dropdown",f)),b.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger("hidden.bs.dropdown",f)))}))}function c(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.1",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=c(e),g=f.hasClass("open");if(b(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click",b);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger("shown.bs.dropdown",h)}return!1}},g.prototype.keydown=function(b){if(/(38|40|27|32)/.test(b.which)&&!/input|textarea/i.test(b.target.tagName)){var d=a(this);if(b.preventDefault(),b.stopPropagation(),!d.is(".disabled, :disabled")){var e=c(d),g=e.hasClass("open");if(!g&&27!=b.which||g&&27==b.which)return 27==b.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.divider):visible a",i=e.find('[role="menu"]'+h+', [role="listbox"]'+h);if(i.length){var j=i.index(b.target);38==b.which&&j>0&&j--,40==b.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",b).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",'[role="menu"]',g.prototype.keydown).on("keydown.bs.dropdown.data-api",'[role="listbox"]',g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$backdrop=this.isShown=null,this.scrollbarWidth=0,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.1",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.options.backdrop&&d.adjustBackdrop(),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in").attr("aria-hidden",!1),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$element.find(".modal-dialog").one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").attr("aria-hidden",!0).off("click.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a('<div class="modal-backdrop '+e+'" />').prependTo(this.$element).on("click.dismiss.bs.modal",a.proxy(function(a){a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus.call(this.$element[0]):this.hide.call(this))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.options.backdrop&&this.adjustBackdrop(),this.adjustDialog()},c.prototype.adjustBackdrop=function(){this.$backdrop.css("height",0).css("height",this.$element[0].scrollHeight)},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){this.bodyIsOverflowing=document.body.scrollHeight>document.documentElement.clientHeight,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right","")},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b,g=f&&f.selector;(e||"destroy"!=b)&&(g?(e||d.data("bs.tooltip",e={}),e[g]||(e[g]=new c(this,f))):e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=this.options=this.enabled=this.timeout=this.hoverState=this.$element=null,this.init("tooltip",a,b)};c.VERSION="3.3.1",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(this.options.viewport.selector||this.options.viewport);for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c&&c.$tip&&c.$tip.is(":visible")?void(c.hoverState="in"):(c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide()},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.options.container?a(this.options.container):this.$element.parent(),p=this.getPosition(o);h="bottom"==h&&k.bottom+m>p.bottom?"top":"top"==h&&k.top-m<p.top?"bottom":"right"==h&&k.right+l>p.width?"left":"left"==h&&k.left-l<p.left?"right":h,f.removeClass(n).addClass(h)}var q=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(q,h);var r=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",r).emulateTransitionEnd(c.TRANSITION_DURATION):r()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top=b.top+g,b.left=b.left+h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=this.tip(),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.width&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){return this.$tip=this.$tip||a(this.options.template)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type)})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b,g=f&&f.selector;(e||"destroy"!=b)&&(g?(e||d.data("bs.popover",e={}),e[g]||(e[g]=new c(this,f))):e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.1",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")},c.prototype.tip=function(){return this.$tip||(this.$tip=a(this.options.template)),this.$tip};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){var e=a.proxy(this.process,this);this.$body=a("body"),this.$scrollElement=a(a(c).is("body")?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",e),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.1",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b="offset",c=0;a.isWindow(this.$scrollElement[0])||(b="position",c=this.$scrollElement.scrollTop()),this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight();var d=this;this.$body.find(this.selector).map(function(){var d=a(this),e=d.data("target")||d.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[b]().top+c,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){d.offsets.push(this[0]),d.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(!e[a+1]||b<=e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.1",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})
})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu")&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=this.unpin=this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.1",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=i?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=a("body").height();"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);/**
 * bootstrap-multiselect.js 1.0.0
 * https://github.com/davidstutz/bootstrap-multiselect
 *
 * Copyright 2012, 2013 David Stutz
 * 
 * Dual licensed under the BSD-3-Clause and the Apache License, Version 2.0.
 * See the README.
 */

/********************************************************
Warning!
This has been modified by IHG to correct IE7/8 bugs, etc.
The latest version provided by the original author has
dropped support for IE<9, so we can NO LONGER UPGRADE
without manual intervention.
AKA: IHG Private Version of Third Party Control. 10/7/13
*********************************************************/

!function($) {"use strict";// jshint ;_;

    if ( typeof ko != 'undefined' && ko.bindingHandlers && !ko.bindingHandlers.multiselect) {
        ko.bindingHandlers.multiselect = {
            init : function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
            },
            update : function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var ms = $(element).data('multiselect');
                if (!ms) {
                    $(element).multiselect(ko.utils.unwrapObservable(valueAccessor()));
                }
                else
                if (allBindingsAccessor().options && allBindingsAccessor().options().length !== ms.originalOptions.length) {
                    ms.updateOriginalOptions();
                    $(element).multiselect('rebuild');
                }
            }
        };
    }

    function Multiselect(select, options) {

        this.options = this.getOptions(options);
        this.$select = $(select);
        this.originalOptions = this.$select.clone()[0].options;
        //we have to clone to create a new reference
        this.query = '';
        this.searchTimeout = null;

        this.options.multiple = this.$select.attr('multiple') == "multiple";

        // Special Select All - Turn this off if not a multi-select dropdown.
        if (this.options.selectAllSpecial && !this.options.multiple) {
            this.options.selectAllSpecial = false;
        }
        // Inverse Select All - Turn this off if not a multi-select dropdown.
        if (this.options.selectAllInverse && !this.options.multiple) {
            this.options.selectAllInverse = false;
        }

        this.$container = $(this.options.buttonContainer).append('<button type="button" class="multiselect dropdown-toggle ' + this.options.buttonClass + '" data-toggle="dropdown">' + this.options.buttonText(this.getSelected(), this.$select) + '</button>')
            .append('<ul class="multiselect-container dropdown-menu' + (this.options.multiple ? ' dimSelected' : '') + (this.options.dropRight ? ' pull-right' : '') + '"></ul>');

        // Manually add button width if set.
        if (this.options.buttonWidth) {
            $('button', this.$container).css({
                'width' : this.options.buttonWidth
            });
        }
        
        // Keep the tab index from the select.
        var tabindex = this.$select.attr('tabindex');
        if (tabindex) {
            $('button', this.$container).attr('tabindex', tabindex);
        }
        
        // Set max height of dropdown menu to activate auto scrollbar.
        if (this.options.maxHeight) {
            // Original Author TODO: Add a class for this option to move the css declarations.
            $('.multiselect-container', this.$container).css({
                'max-height' : this.options.maxHeight + 'px',
                'overflow-y' : 'auto',
                'overflow-x' : 'hidden'
            });
        }

        // Enable filtering.
        if (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering) {
            var enableFilterLength = Math.max(this.options.enableFiltering, this.options.enableCaseInsensitiveFiltering);
            if (this.$select.find('option').length >= enableFilterLength) {
                this.buildFilter();
            }
        }
        
        // Build select all if enabled.
        this.buildSelectAll();
        this.buildDropdown();
        this.updateButtonText();

        this.$select.hide().after(this.$container);
    };

    Multiselect.prototype = {

        defaults: {
            // Default text function will either print 'None selected' in case no
            // option is selected, or a list of the selected options up to a length of 3 selected options.
            // If more than 3 options are selected, the number of selected options is printed.
            buttonText: function(options, select) {
                if (options.length == 0) {
                    return this.nonSelectedText + '<b class="caret"></b>';
                }
                else
                if (options.length > 3) {
                    return options.length + ' ' + this.nSelectedText + ' <b class="caret"></b>';
                }
                else {
                    var selected = '';
                    options.each(function() {
                        var label = ($(this).attr('label') !== undefined) ? $(this).attr('label') : $(this).html();

                        selected += label + ', ';
                    });
                    return selected.substr(0, selected.length - 2) + ' <b class="caret"></b>';
                }
            },
            // Like the buttonText option to update the title of the button.
            buttonTitle: function(options, select) {
                var selected = '';
                options.each(function () {
                    selected += $(this).text() + ', ';
                });
                return selected.substr(0, selected.length - 2);
            },
            // Is triggered on change of the selected options.
            onChange : function(option, checked) {

            },
            buttonClass: 'btn',
            dropRight: false,
            selectedClass: 'active',
            buttonWidth: 'auto',
            buttonContainer: '<div class="btn-group" />',
            // Maximum height of the dropdown menu.
            // If maximum height is exceeded a scrollbar will be displayed.
            maxHeight: false,
            includeSelectAllOption: false,
            selectAllText: ' Select all',
            selectAllValue: 'multiselect-all',
            selectAllSpecial: false,
            selectAllInverse: false,
            currentBrandCode: '',
            enableFiltering: false,
            enableCaseInsensitiveFiltering: false,
            filterPlaceholder: 'Search',
            // possible options: 'text', 'value', 'both'
            filterBehavior: 'text',
            preventInputChangeEvent: false,
            nonSelectedText: 'None selected',
            nSelectedText: 'selected'
        },

        constructor: Multiselect,

        // Will build an dropdown element for the given option.
        createOptionValue: function(element) {
            if ($(element).is(':selected')) {
                $(element).attr('selected', 'selected').prop('selected', true);
            }

            // Support the label attribute on options.
            var label = $(element).attr('label') || $(element).html();
            var value = $(element).val();
            var inputType = this.options.multiple ? "checkbox" : "radio";

            var $li = $('<li><a href="javascript:void(0);"><label class="' + inputType + '"><input type="' + inputType + '" /></label></a></li>');

            var selected = $(element).prop('selected') || false;
            var $checkbox = $('input', $li);
            $checkbox.val(value);

            if (value == this.options.selectAllValue) {
                $checkbox.parent().parent().addClass('multiselect-all');
            }

            $('label', $li).append(" " + label);

            $('.multiselect-container', this.$container).append($li);

            if ($(element).is(':disabled')) {
                $checkbox.attr('disabled', 'disabled').prop('disabled', true).parents('li').addClass('disabled');
            }

            $checkbox.prop('checked', selected);

            if (selected && this.options.selectedClass) {
                $checkbox.parents('li').addClass(this.options.selectedClass);
            }
        },

        toggleActiveState: function(shouldBeActive) {
            if (this.$select.attr('disabled') == undefined) {
                $('button.multiselect.dropdown-toggle', this.$container).removeClass('disabled');
            }
            else {
                $('button.multiselect.dropdown-toggle', this.$container).addClass('disabled');
            }
        },

        // Add the select all option to the select.
        buildSelectAll: function() {
            var alreadyHasSelectAll = this.$select[0][0] ? this.$select[0][0].value == this.options.selectAllValue : false;

            // If options.includeSelectAllOption === true, add the include all checkbox.
            if (this.options.includeSelectAllOption && this.options.multiple && !alreadyHasSelectAll) {
                this.$select.prepend('<option value="' + this.options.selectAllValue + '">' + this.options.selectAllText + '</option>');
            }
        },

        // Build the dropdown and bind event handling.
        buildDropdown: function() {
            this.toggleActiveState();

            this.$select.children().each($.proxy(function(index, element) {
                // Support optgroups and options without a group simultaneously.
                var tag = $(element).prop('tagName').toLowerCase();
                if (tag == 'optgroup') {
                    var group = element;
                    var groupName = $(group).prop('label');

                    // Add a header for the group.
                    var $li = $('<li><label class="multiselect-group"></label></li>');
                    $('label', $li).text(groupName);
                    $('.multiselect-container', this.$container).append($li);

                    // Add the options of the group.
                    $('option', group).each($.proxy(function(index, element) {
                        this.createOptionValue(element);
                    }, this));
                }
                else
                if (tag == 'option') {
                    this.createOptionValue(element);
                }
                else {
                    // Ignore illegal tags.
                }
            }, this));

            // Bind the change event on the dropdown elements.
            $('.multiselect-container li input', this.$container).on('change', $.proxy(function(event) {
                var checked = $(event.target).prop('checked') || false;
                var isSelectAllOption = $(event.target).val() == this.options.selectAllValue;

                // Apply or unapply the configured selected class.
                if (this.options.selectedClass) {
                    if (checked) {
                        $(event.target).parents('li').addClass(this.options.selectedClass);
                    }
                    else {
                        $(event.target).parents('li').removeClass(this.options.selectedClass);
                    }
                }

                var $option = $('option', this.$select).filter(function() {
                    return $(this).val() == $(event.target).val();
                });

                var $optionsNotThis = $('option', this.$select).not($option);
                var $optionsCount = $('option:selected', this.$select).not($option).length;
                var $checkboxesNotThis = $('input', this.$container).not($(event.target));
                var $selectAllInput = $('input:first', this.$container);
                var $selectCurrentBrand = $('input[value="' + this.options.currentBrandCode + '"]',  this.$container);

                // Toggle all options if the select all option was changed.
                if (isSelectAllOption) {
                    if (this.options.selectAllSpecial) {
                        if ($selectAllInput.is(':checked')) {
                            // Special Select All - Check 'All' checkboxes ...
                            $checkboxesNotThis.filter(function() {
                                return $(this).is(':checked') == false;
                            }).trigger('click');
                        }
                        else {
                            // Special Select All - Uncheck 'All' checkboxes (except the current Brand below).
                            $checkboxesNotThis.filter(function() {
                                return $(this).is(':checked') == true;
                            }).trigger('click');

                            // Special Select All - Re-Check only the current Brand.
                            $selectCurrentBrand.prop('checked', true);
                            $selectCurrentBrand.change();
                        }
                    }
                    else if (this.options.selectAllInverse) {
                        if ($selectAllInput.is(':checked')) {
                            // Inverse Select All - Uncheck everything else...
                            $checkboxesNotThis.filter(function() {
                                return $(this).is(':checked');
                            }).trigger('click');
                            // Inverse Select All - Disable the 'All' checkbox...
                            $selectAllInput.attr('disabled', 'disabled').prop('disabled', true).parents('li').addClass('disabled');
                        }
                        else {
                            // Inverse Select All - Re-enable the 'All' checkbox...
                            $selectAllInput.removeAttr('disabled').prop('disabled', false).parents('li').removeClass('disabled');
                        }
                    }
                    else {
                        // Default Select All - toggle checkboxes...
                        $checkboxesNotThis.filter(function() {
                            return $(this).is(':checked') != checked;
                        }).trigger('click');
                    }
                }
                else {
                    if (this.options.selectAllSpecial) {
                        var $optionsCountAll = $('option:selected[value!="' + this.options.selectAllValue + '"]', this.$select).length
                        var $optionsCountMax = $('option[value!="' + this.options.selectAllValue + '"]', this.$select).length;

                        // Special Select All - Turn Off the 'All' checkbox if anything else selected...
                        if ($selectAllInput.is(':checked') && ($optionsCountAll === $optionsCountMax) && !checked) {
                            // Special Select All - Uncheck the 'All' checkbox and refresh it...
                            $selectAllInput.prop('checked', false);
                        }
                        // Special Select All - Turn On the 'All' checkbox if there are no other selections...
                        else if (!$selectAllInput.is(':checked') && ($optionsCountAll === ($optionsCountMax-1)) && checked) {
                            // Special Select All - Check the 'All' checkbox and refresh it...
                            $selectAllInput.prop('checked', true);
                        }
                    }
                    else if (this.options.selectAllInverse) {
                        // Inverse Select All - Turn Off the 'All' checkbox if anything else selected...
                        if ($selectAllInput.is(':checked') && $optionsCount === 1) {
                            // Inverse Select All - Uncheck the 'All' checkbox and refresh it...
                            $selectAllInput.prop('checked', false);
                            $selectAllInput.change();
                        }
                        // Inverse Select All - Turn On the 'All' checkbox if there are no other selections...
                        else if (!$selectAllInput.is(':checked') && $optionsCount === 0 && !checked) {
                            // Inverse Select All - Check the 'All' checkbox and refresh it...
                            $selectAllInput.prop('checked', true);
                            $selectAllInput.change();
                        }
                    }
                }

                if (checked) {
                    $option.prop('selected', true);

                    if (this.options.multiple) {
                        $option.attr('selected', 'selected');
                    }
                    else {
                        if (this.options.selectedClass) {
                            $($checkboxesNotThis).parents('li').removeClass(this.options.selectedClass);
                        }

                        $($checkboxesNotThis).prop('checked', false);

                        $optionsNotThis.removeAttr('selected').prop('selected', false);

                        // It's a single selection, so close.
                        $(this.$container).find(".multiselect.dropdown-toggle").click();
                    }

                    if (this.options.selectedClass == "active") {
                        $optionsNotThis.parents("a").css("outline", "");
                    }

                }
                else {
                    $option.removeAttr('selected').prop('selected', false);
                }

                this.updateButtonText();

                this.options.onChange($option, checked);

                this.$select.change();

                if(this.options.preventInputChangeEvent) {
                    return false;
                }
            }, this));

            $('.multiselect-container li a', this.$container).on('touchstart click', function(event) {
                event.stopPropagation();
                $(event.target).blur();
            });

            // Keyboard support.
            this.$container.on('keydown', $.proxy(function(event) {
                if ($('input[type="text"]', this.$container).is(':focus'))
                    return;
                if ((event.keyCode == 9 || event.keyCode == 27) && this.$container.hasClass('open')) {
                    // Close on tab or escape.
                    $(this.$container).find(".multiselect.dropdown-toggle").click();
                }
                else {
                    var $items = $(this.$container).find("li:not(.divider):visible a");

                    if (!$items.length) {
                        return;
                    }

                    var index = $items.index($items.filter(':focus'));

                    // Navigation up.
                    if (event.keyCode == 38 && index > 0) {
                        index--;
                    }
                    // Navigate down.
                    else
                    if (event.keyCode == 40 && index < $items.length - 1) {
                        index++;
                    }
                    else
                    if (!~index) {
                        index = 0;
                    }

                    var $current = $items.eq(index);
                    $current.focus();

                    // Override style for items in li:active.
                    if (this.options.selectedClass == "active") {
                        // Original Author TODO: Fix this bug...
                        //$current.css("outline", "thin dotted #333").css("outline", "5px auto -webkit-focus-ring-color");

                        $items.not($current).css("outline", "");
                    }

                    // Enter key or space bar.
                    if (event.keyCode == 32 || event.keyCode == 13) {
                        var $checkbox = $current.find('input');
                        if (!$checkbox.prop('disabled')) {
                            $checkbox.prop("checked", !$checkbox.prop("checked"));
                            $checkbox.change();
                        }
                    }

                    event.stopPropagation();
                    event.preventDefault();
                }
            }, this));
        },

        // Build and bind filter.
        buildFilter: function() {
            $('.multiselect-container', this.$container).prepend('<div class="input-prepend"><span class="add-on"><i class="icon-search"></i></span><input class="multiselect-search" type="text" placeholder="' + this.options.filterPlaceholder + '"></div>');

            $('.multiselect-search', this.$container).val(this.query).on('click', function(event) {
                event.stopPropagation();
            }).on('keydown', $.proxy(function(event) {
                // This is useful to catch "keydown" events after the browser has
                // updated the control.
                clearTimeout(this.searchTimeout);

                this.searchTimeout = this.asyncFunction($.proxy(function() {

                    if (this.query != event.target.value) {
                        this.query = event.target.value;

                        $.each($('.multiselect-container li', this.$container), $.proxy(function(index, element) {
                            var value = $('input', element).val();
                            if (value != this.options.selectAllValue) {
                                var text = $('label', element).text();
                                var value = $('input', element).val();
                                if (value && text && value != this.options.selectAllValue) {
                                    // by default lets assume that element is not
                                    // interesting for this search
                                    var showElement = false;

                                    var filterCandidate = '';
                                    if ((this.options.filterBehavior == 'text' || this.options.filterBehavior == 'both')) {
                                        filterCandidate = text;
                                    }
                                    if ((this.options.filterBehavior == 'value' || this.options.filterBehavior == 'both')) {
                                        filterCandidate = value;
                                    }

                                    if (this.options.enableCaseInsensitiveFiltering && filterCandidate.toLowerCase().indexOf(this.query.toLowerCase()) > -1) {
                                        showElement = true;
                                    }
                                    else if (filterCandidate.indexOf(this.query) > -1) {
                                        showElement = true;
                                    }

                                    if (showElement) {
                                        $(element).show();
                                    }
                                    else {
                                        $(element).hide();
                                    }
                                }
                            }
                        }, this));
                    }
                }, this), 300, this);
            }, this));
        },

        // Destroy - unbind - the plugin.
        destroy: function() {
            this.$container.remove();
            this.$select.show();
        },

        // Refreshs the checked options based on the current state of the select.
        refresh: function() {
            $('option', this.$select).each($.proxy(function(index, element) {
                var $input = $('.multiselect-container li input', this.$container).filter(function() {
                    return $(this).val() == $(element).val();
                });

                if ($(element).is(':selected')) {
                    $input.prop('checked', true);

                    if (this.options.selectedClass) {
                        $input.parents('li').addClass(this.options.selectedClass);
                    }
                }
                else {
                    $input.prop('checked', false);

                    if (this.options.selectedClass) {
                        $input.parents('li').removeClass(this.options.selectedClass);
                    }
                }

                if ($(element).is(":disabled")) {
                    $input.attr('disabled', 'disabled').prop('disabled', true).parents('li').addClass('disabled');
                }
                else {
                    $input.removeAttr('disabled').prop('disabled', false).parents('li').removeClass('disabled');
                }
            }, this));

            this.updateButtonText();
        },

        // Select an option by its value.
        select: function(value) {
            var $option = $('option', this.$select).filter(function() {
                return $(this).val() == value;
            });
            var $checkbox = $('.multiselect-container li input', this.$container).filter(function() {
                return $(this).val() == value;
            });

            if (this.options.selectedClass) {
                $checkbox.parents('li').addClass(this.options.selectedClass);
            }

            $checkbox.prop('checked', true);

            $option.attr('selected', 'selected').prop('selected', true);

            this.updateButtonText();
            this.options.onChange($option, true);
        },

        // Deselect an option by its value.
        deselect: function(value) {
            var $option = $('option', this.$select).filter(function() {
                return $(this).val() == value;
            });
            var $checkbox = $('.multiselect-container li input', this.$container).filter(function() {
                return $(this).val() == value;
            });

            if (this.options.selectedClass) {
                $checkbox.parents('li').removeClass(this.options.selectedClass);
            }

            $checkbox.prop('checked', false);

            $option.removeAttr('selected').prop('selected', false);

            this.updateButtonText();
            this.options.onChange($option, false);
        },

        // Rebuild the whole dropdown menu.
        rebuild: function() {
            $('.multiselect-container', this.$container).html('');
            
            this.buildSelectAll();
            this.buildDropdown(this.$select, this.options);
            this.updateButtonText();

            // Enable filtering.
            if (this.options.enableFiltering || this.options.enableCaseInsensitiveFiltering) {
                this.buildFilter();
            }
        },

        // Get options by merging defaults and given options.
        getOptions: function(options) {
            return $.extend({}, this.defaults, options);
        },

        updateButtonText: function() {
            var options = this.getSelected();
            
            // First update the displayed button text.
            $('button', this.$container).html(this.options.buttonText(options, this.$select));
            
            // Now update the title attribute of the button.
            $('button', this.$container).attr('title', this.options.buttonTitle(options, this.$select));
            
        },

        // Get all selected options.
        getSelected: function() {
            return $('option:selected[value!="' + this.options.selectAllValue + '"]', this.$select);
        },

        updateOriginalOptions: function() {
            this.originalOptions = this.$select.clone()[0].options;
        },

        asyncFunction: function(callback, timeout, self) {
            var args = Array.prototype.slice.call(arguments, 3);
            return setTimeout(function() {
                callback.apply(self || window, args);
            }, timeout);
        }
    };

    $.fn.multiselect = function(option, parameter) {
        return this.each(function() {
            var data = $(this).data('multiselect'), options = typeof option == 'object' && option;

            // Initialize the multiselect.
            if (!data) {
                $(this).data('multiselect', ( data = new Multiselect(this, options)));
            }

            // Call multiselect method.
            if ( typeof option == 'string') {
                data[option](parameter);
            }
        });
    };

    $.fn.multiselect.Constructor = Multiselect;

    $(function() {
        $("select[data-role=multiselect]").multiselect();
    });

}(window.jQuery);
!function ($) {

    /* MODAL POPOVER PUBLIC CLASS DEFINITION
     * =============================== */

    var lastActiveElement = null;

    var ModalPopover = function (element, options) {
        this.options = options;
        this.options.backdrop = true;
        this.$element = $(element)
            .delegate('[data-dismiss="modal-popup"]', 'click.dismiss.modal-popup', $.proxy(this.hide, this));
        this.options.remote && this.$element.find('.popover-content').load(this.options.remote);
        this.$parent = options.$parent; // author todo make sure parent is specified
        this.$body = $(document.body);
    }


    /* NOTE: MODAL POPOVER EXTENDS BOOTSTRAP-MODAL.js
     ========================================== */


    ModalPopover.prototype = $.extend({}, $.fn.modal.Constructor.prototype, {

        constructor:ModalPopover,


        getPosition:function () {
            var $element = lastActiveElement || this.$parent;
            return $.extend({}, ($element.offset()), {
                width:$element[0].offsetWidth, height:$element[0].offsetHeight
            });
        },

        show:function () {
            var $dialog = this.$element;
            $dialog.css({ top:0, left:0, display:'block', 'z-index':1050 });

            var placement = typeof this.options.placement == 'function' ?
                this.options.placement.call(this, $tip[0], this.$element[0]) :
                this.options.placement;

            var pos = this.getPosition();

			pos.top = pos.top - $dialog.offsetParent().offset().top;
			
			
            var actualWidth = $dialog[0].offsetWidth;
            var actualHeight = $dialog[0].offsetHeight;

            // RTL support added...
            $isRTL = $dialog.css('direction') === 'rtl';

            var tp;
            switch (placement) {
                case 'bottom':
                    tp = {top:pos.top + pos.height, left:pos.left + pos.width / 2 - actualWidth / 2}
                    break;
                case 'top':
                    tp = {top:pos.top - actualHeight, left:pos.left + pos.width / 2 - actualWidth / 2}
                    break;
                case 'left':
                    tp = {top:pos.top + pos.height / 2 - actualHeight / 2, left:pos.left - actualWidth}
                    break;
                case 'left-top':
                    if ($isRTL) {
                        if (this.$element.attr('id') === 'bonusPointsPopup') {
                            tp = {top:pos.top + pos.height / 2 - 46, left:pos.width + 120 + actualWidth}
                        } else {
                            tp = {top:pos.top + pos.height / 2 - 46, left:pos.width / 2 + actualWidth}
                        }
                    } else {
                        tp = {top:pos.top + pos.height / 2 - 46, left:pos.left - actualWidth}
                    }
                    break;
                case 'right':
                    tp = {top:pos.top + pos.height / 2 - actualHeight / 2, left:pos.left + pos.width}
                    break;
                case 'right-top':
                    tp = {top:pos.top + pos.height / 2 - 92, left:pos.left + pos.width}
                    break;
            }

            $dialog
                .css(tp)
                .addClass(placement)
                .addClass('in');


            $.fn.modal.Constructor.prototype.show.call(this, arguments); // super
        },

        /** todo entire function was copied just to set the background to 'none'.  need a better way */
        backdrop:function (callback) {
            var that = this;
            var animate = this.$element.hasClass('fade') ? 'fade' : '';

            if (this.isShown && this.options.backdrop) {
                var doAnimate = $.support.transition && animate;
                var seeThru = this.$element.hasClass('darkness') ? '" />' : '" style="background:none" />';
                this.$backdrop = $('<div class="modal-backdrop ' + animate + seeThru)
                    .appendTo(document.body);

                if (this.options.backdrop != 'static') {
                    this.$backdrop.click($.proxy(this.hide, this));
                }

                if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

                this.$backdrop.addClass('in');

                doAnimate ?
                    this.$backdrop.one($.support.transition.end, callback) :
                    callback();

            } else if (!this.isShown && this.$backdrop) {
                this.$backdrop.removeClass('in');

                $.support.transition && this.$element.hasClass('fade') ?
                    this.$backdrop.one($.support.transition.end, $.proxy(this.removeBackdrop, this)) :
                    this.removeBackdrop();

            } else if (callback) {
                callback();
            }
        }

    });


    /* MODAL POPOVER PLUGIN DEFINITION
     * ======================= */

    $.fn.modalPopover = function (option) {
        return this.each(function () {
            var $this = $(this);
            var data = $this.data('modal-popover');
            var options = $.extend({}, $.fn.modalPopover.defaults, $this.data(), typeof option == 'object' && option);
            // author todo need to replace 'parent' with 'target'
            options['$parent'] = (data && data.$parent) || option.$parent || $(options.target);

            if (!data) $this.data('modal-popover', (data = new ModalPopover(this, options)))

            if (typeof option == 'string') data[option]()
        })
    }

    $.fn.modalPopover.Constructor = ModalPopover

    $.fn.modalPopover.defaults = $.extend({}, $.fn.modal.defaults, {
        placement:'right',
        keyboard: true
    });


    $(function () {
        $('body').on('click.modal-popover.data-api', '[data-toggle="modal-popover"]', function (e) {
            var $this = $(this);
            lastActiveElement = $this;
            var href = $this.attr('href');
            var $dialog = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))); //strip for ie7
            var option = $dialog.data('modal-popover') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $dialog.data(), $this.data());
            option['$parent'] = $this;

            e.preventDefault();

            // Added this to support dynamic content in popups...
            if ($this.attr('data-dynamic')) {
                $dialog.trigger('data-dynamic', $this);
            }

            $dialog
                .modalPopover(option)
                .modalPopover('show')
                .one('hide', function () {
                    $this.focus()
                })
        })
    })

}(window.jQuery);
/*
http://stackoverflow.com/questions/1987524/turn-a-number-into-star-rating-display-using-jquery-and-css
*/
!function ($) {
	"use strict"; // jshint ;_;

	// Star Ratings.
	$.fn.stars = function () {
		return $(this).each(function() {

			// Get the value
			var val = parseFloat($(this).html());

			if( isNaN(val) ) {
				return;
			}
			
			// Make sure that the value is in 0 - 5 range, multiply to get width
			var size = Math.max(0,(Math.min(5,val)))*13;

			// RTL support... Note: Only 'whole stars' can be displayed for RTL.
			if ($(this).css('direction') === 'rtl') {
				size -= size % 13;
			}

			// Create stars holder
			var $span = $('<span />').width(size);

			// Replace the numerical value with stars
			$(this).html($span);
		});
	}
}(window.jQuery);
/*! datepickerplus 0.2.6 - 2014-02-21 */!function(a,b){var c=["destroy","dialog","getDate","hide","isDisabled","option","refresh","setDate","show","widget"],d=(Function.prototype.compose||(Function.prototype.compose=function(a){var b=this;return function(){var c=Array.prototype.slice.call(arguments,0);return c.push(a.apply(null,arguments)),b.apply(null,c)}}),"52em"),e="ui-datepicker-div";a.widget("ui.datepickerplus",{options:{headerContent:"",footerContent:"",highlightRange:!1,rangeStart:null,rangeEnd:null,rangeStartLabel:"checkindate",rangeEndLabel:"checkoutdate",selectableOnMinDateMinusOne:!1,resettable:!0,resettableClass:"calendar-reset",initialDateRange:0,allowedRange:14,closeClass:"calendar-close",inline:null},_create:function(){var d=this;this.$el=this.element,this.options.onSelect=this.options.onSelect?this._onSelect.compose(this.options.onSelect):this._onSelect,this.options.beforeShow=this.options.beforeShow?this._onBeforeShow.compose(this.options.beforeShow):this._onBeforeShow,this.options.onChangeMonthYear=this.options.onChangeMonthYear?this._onChangeMonthYear.compose(this.options.onChangeMonthYear):this._onChangeMonthYear,this._initializeDatepickerPlus();var f,g=a.datepicker._getInst(this.$el[0]);try{f=a.datepicker._getInst(a("#"+this.options.pairedWith)[0])}catch(h){}g.settings.minDate||(g.settings.minDate=new Date);var i;try{i=new Date(g.settings.minDate.getTime())}catch(h){i=new Date}i.setDate(i.getDate()+350),g.settings.maxDate||(g.settings.maxDate=i);var j,k=this.options.dateFormat?this.options.dateFormat:a.datepicker._defaults.dateFormat;try{j=a.datepicker.parseDate(k,this.$el.val())}catch(l){console.log(l+": probably caused by non-date value"),j=""}var m=g.settings.minDate;m.setDate(m.getDate()-1);var n=new Date;if(n=new Date(n.getFullYear(),n.getMonth(),n.getDate()),g.settings.selectableOnMinDateMinusOne&&(n=new Date(n.getTime()-864e5)),j&&j.getTime()<n.getTime()&&(this.$el.val(""),j=b),j){if(-1!=this.$el.attr("id").toLowerCase().indexOf(this.options.rangeStartLabel)){this.options.rangeStart=new Date(j.getTime());var o=a.datepicker.parseDate(k,a("#"+this.options.pairedWith).val());o&&(this.options.rangeEnd=new Date(o.getTime())),this.options.selectableOnMinDateMinusOne&&(g.settings.minDate=m)}if(-1!=this.$el.attr("id").toLowerCase().indexOf(this.options.rangeEndLabel)){this.options.rangeEnd=new Date(j.getTime());var p=a.datepicker.parseDate(k,a("#"+this.options.pairedWith).val());if(p){this.options.rangeStart=new Date(p.getTime());var q=new Date(this.options.rangeStart.getTime());g.settings.minDate=q;var r=new Date(this.options.rangeStart.getTime());r.setDate(r.getDate()+99),r<g.settings.maxDate&&(g.settings.maxDate=r)}}}else-1!=this.$el.attr("id").toLowerCase().indexOf(this.options.rangeStartLabel)&&this.options.selectableOnMinDateMinusOne&&(g.settings.minDate=m),-1!=this.$el.attr("id").toLowerCase().indexOf(this.options.rangeEndLabel)&&f&&g.settings.minDate.setDate(f.settings.minDate.getDate()+1);var s=a("#"+e);this.options.resettable&&s.on("click","."+this.options.resettableClass,function(a){a.preventDefault(),d._resetCalendar.apply(d)}),s.on("click","."+this.options.closeClass,function(a){a.preventDefault(),d._closeCalendar.apply(d)}),null!==g.settings.inline&&(g.inline=g.settings.inline),a.each(c,function(a,b){d[b]=function(){var a=Array.prototype.slice.call(arguments,0);a.splice(0,0,b);var c=d.$el.datepicker.apply(d.$el,a);return"option"===b&&(d.options.rangeStart=d.$el.datepicker("option","rangeStart"),d.options.rangeEnd=d.$el.datepicker("option","rangeEnd")),c}})},_closeCalendar:function(){var b=a.datepicker._curInst;a.datepicker._hideDatepicker(b.input[0])},_resetCalendar:function(){var b=a.datepicker._curInst;if(a.trim(a(b.input[0]).val())){var c="";c=null!==c?c:a.datepicker._formatDate(b),b.input&&a("#"+b.input[0].id).parent().parent().find(".hasDatepicker").val(c),a.datepicker._updateAlternate(b);var d=a.datepicker._get(b,"onSelect");d?d.apply(b.input?b.input[0]:null,[c,b]):b.input&&b.input.trigger("change"),b.inline?a.datepicker._updateDatepicker(b):(a.datepicker._lastInput=b.input[0],"object"!=typeof b.input[0]&&b.input.focus(),a.datepicker._lastInput=null),this._clearHightlightRange()}},_clearHightlightRange:function(){var c=this,d=a.datepicker._curInst,f=a(d.input[0]).data("ui-datepickerplus"),g=a("#"+f.options.pairedWith).data("ui-datepickerplus"),h=d.input[0];if(-1!=h.id.toLowerCase().indexOf(d.settings.rangeStartLabel)&&""===a(h).val()&&(f.options.rangeStart=b,g.options.rangeStart=b),-1!=h.id.toLowerCase().indexOf(d.settings.rangeEndLabel)&&""===a(h).val()&&(f.options.rangeEnd=b,g.options.rangeEnd=b),d.settings.highlightRange){var i=a.datepicker._curInst.settings.minDate,j=a("#"+e);j.find("table.ui-datepicker-calendar tbody td a, table.ui-datepicker-calendar tbody td span").each(function(b,e){var f=a(e);if(-1!=h.id.toLowerCase().indexOf(d.settings.rangeStartLabel)&&f.hasClass("ui-datepicker-range-start")){f.removeClass("ui-datepicker-range-start");var g=f.parent();g&&(g.attr("class","").attr("data-handler","selectDay").attr("data-event","click").attr("data-month",i.getMonth()).attr("data-year",i.getFullYear()).html('<a class="ui-state-default" href="#">'+f.text()+"</a>"),g.bind("click",{id:"#"+a.datepicker._curInst.id,month:i.getMonth(),year:i.getFullYear(),td:g[0]},c._selectDay),g.find("a").bind("click",function(a){a.preventDefault()})),f.remove()}f.removeClass("ui-datepicker-range-end"),f.removeClass("ui-datepicker-range")})}},_selectDay:function(b){a.datepicker._selectDay(b.data.id,b.data.month,b.data.year,b.data.td)},_onChangeMonthYear:function(b,c,d){var e=a(d.input[0]).data("ui-datepickerplus");setTimeout(function(){e._render()},0)},_onBeforeShow:function(b){var c=a(b).data("ui-datepickerplus");setTimeout(function(){c._render()},0)},_onSelect:function(c,d){if(d.settings.highlightRange){var e=a(d.input[0]).data("ui-datepickerplus"),f=a("#"+e.options.pairedWith),g=f.data("ui-datepickerplus"),h=a.datepicker._getInst(f[0]),i=new Date(d.selectedYear,d.selectedMonth,d.selectedDay),j=a(d.input[0]).attr("id");if(-1!=j.toLowerCase().indexOf(d.settings.rangeStartLabel)){var k=new Date(i.getTime());if(k.setDate(k.getDate()+1),e.options.rangeStart&&(k=e.options.rangeStart,k.setDate(e.options.rangeStart.getDate()-e.options.allowedRange)),e.options.rangeStart=new Date(i.getTime()),g.options.rangeStart=e.options.rangeStart,e.options.initialDateRange>0){if(k>i||i>=e.options.rangeEnd){if(e.options.rangeStart>e.options.rangeEnd){var l=new Date;l.setDate(l.getDate()+350),h.settings.maxDate=l}h.settings.minDate=i;var m=new Date(i.getTime());m.setDate(i.getDate()+e.options.initialDateRange),a.datepicker._setDate(h,m,!1),e.options.rangeEnd=new Date(m.getTime()),g.options.rangeEnd=e.options.rangeEnd}}else if(e.options.rangeStart>e.options.rangeEnd){a.datepicker._selectDate("#"+e.options.pairedWith,""),e.options.rangeEnd=b,g.options.rangeEnd=b;var n=new Date;n.setDate(n.getDate()+350),h.settings.maxDate=n}h.settings.minDate=i;var o=new Date(i);o.setDate(o.getDate()+99),o<h.settings.maxDate&&(h.settings.maxDate=o)}if(-1!=j.toLowerCase().indexOf(d.settings.rangeEndLabel)){if(g.options.initialDateRange>0&&!g.options.rangeStart){var p=new Date(i.getTime());p.setDate(p.getDate()-g.options.initialDateRange),d.settings.minDate=p,a.datepicker._setDate(h,p,!1),g.options.rangeStart=p,e.options.rangeStart=g.options.rangeStart}e.options.rangeEnd=new Date(i.getTime()),g.options.rangeEnd=e.options.rangeEnd}e.options.rangeStart&&e.options.rangeEnd&&e.options.rangeStart<e.options.rangeEnd&&e._highlightRange()}},_selectableOnMinDateMinusOne:function(){var b=a.datepicker._curInst;if(b.settings.selectableOnMinDateMinusOne){var c=(a(b.input[0]).data("ui-datepickerplus"),a("#"+e));c.find("table.ui-datepicker-calendar tbody td a").each(function(c,d){var e=a(d),f=a.trim(e.text()),g=e.parent().attr("data-month"),h=e.parent().attr("data-year"),i=new Date(h,g,f),j=b.settings.minDate;j.getFullYear()==i.getFullYear()&&j.getMonth()==i.getMonth()&&j.getDate()==i.getDate()&&e.removeClass().addClass("ui-state-default-pastdate ui-state-active")})}},_highlightRange:function(){var b=a.datepicker._curInst,c=a(b.input[0]).data("ui-datepickerplus"),d=a("#"+e);d.find("table.ui-datepicker-calendar tbody td a").each(function(b,d){var e=a(d),f=a.trim(e.text()),g=e.parent().attr("data-month"),h=e.parent().attr("data-year"),i=new Date(h,g,f);e.removeClass("ui-datepicker-range-start ui-datepicker-range-end ui-datepicker-range"),c.options.rangeStart&&(c.options.rangeStart.getTime()===i.getTime()&&(e.parent().append('<span class="ui-state-default ui-datepicker-range-start">'+f+"</span>"),e.parent().unbind(),e.remove()),c.options.rangeEnd&&(c.options.rangeEnd.getTime()===i.getTime()&&e.addClass("ui-datepicker-range-end"),c.options.rangeStart.getTime()<i.getTime()&&i.getTime()<c.options.rangeEnd.getTime()&&e.addClass("ui-datepicker-range")))})},_initializeDatepickerPlus:function(){if(this.options.highlightRange){if(!this.options.pairedWith)throw"pairedWith option must be set for hightlightRange option";if(0===a("#"+this.options.pairedWith).length)throw"No input field with id="+this.options.pairedWith+" is found. Please check if you have correct pairedWith option."}this.$el.datepicker(this.options);var b=this;this.$el.keyup(function(){b._render()})},_showHeader:function(){var b=a.datepicker._curInst,c=a("#"+e);if(b.settings.headerContent){var d=c.find("#ui-datepicker-customized-header");0===d.length&&(c.prepend('<div id="ui-datepicker-customized-header"></div>'),d=c.find("#ui-datepicker-customized-header")),d.html(b.settings.headerContent)}},_showFooter:function(){var b=a.datepicker._curInst,c=a("#"+e);if(b.settings.footerContent){var d=c.find("#ui-datepicker-customized-footer");0===d.length&&(c.append('<div id="ui-datepicker-customized-footer"></div>'),d=c.find("#ui-datepicker-customized-footer")),d.html(b.settings.footerContent)}},_render:function(){if(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)){var b=a("#"+e);b.css({width:d});var c=b.width(),f=screen.width-c-40,g=parseInt(b.css("left"),10);g>f&&b.css({width:d,left:f+"px"})}this._selectableOnMinDateMinusOne(),this._highlightRange(),this._showHeader(),this._showFooter()}})}(jQuery);jQuery(function($) {
	$.datepicker.regional['usen'] = {
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: ''}; // Additional text to append to the year in the month headers
	$.datepicker.regional['cnzh'] = {
		closeText: '',
		prevText: '&#x3c;',
		nextText: '&#x3e;',
		currentText: '',
		monthNames: ['','','','','','','','','','','',''],
		monthNamesShort: ['','','','','','','','','','','',''],
		dayNames: ['','','','','','',''],
		dayNamesShort: ['','','','','','',''],
		dayNamesMin: ['','','','','','',''],
		weekHeader: '',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: true,
		yearSuffix: ''};
	$.datepicker.regional['twzh'] = {
			closeText: '',
			prevText: '&#x3c;',
			nextText: '&#x3e;',
			currentText: '',
			monthNames: ['','','','','','','','','','', '',''],
			monthNamesShort: ['','','','','','','','','','', '',''],
			dayNames: ['','','','','','',''],
	        dayNamesShort: ['','','','','','',''],
			dayNamesMin: ['','','','','','',''],
			weekHeader: '',
			dateFormat: 'yy-mm-dd',
			firstDay: 1,
			isRTL: false,
			showMonthAfterYear: true,
			yearSuffix: ''};
	$.datepicker.regional['dede'] = {
		closeText: 'schlieen',
		prevText: '&#x3c;zurck',
		nextText: 'Vor&#x3e;',
		currentText: 'heute',
		monthNames: ['Januar','Februar','Mrz','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember'],
		monthNamesShort: ['Jan','Feb','Mrz','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'],
		dayNames: ['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],
		dayNamesShort: ['So','Mo','Di','Mi','Do','Fr','Sa'],
		dayNamesMin: ['So','Mo','Di','Mi','Do','Fr','Sa'],
		weekHeader: 'Wo',
		dateFormat: 'dd.mm.yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['nlnl'] = {
			closeText:	 'sluiten',
			prevText:	 '&#x3c;vorige',
			nextText:	 'volgende&#x3e;',
			currentText:	 'vandaag',
			monthNames:	 ['januari','februari','maart','april','mei','juni','juli','augustus','september','oktober','november','december'],
			monthNamesShort:	 ['jan','feb','mrt','apr','mei','jun','jul','aug','sep','okt','nov','dec'],
			dayNames:	 ['zondag','maandag','dinsdag','woensdag','donderdag','vrijdag','zaterdag'],
			dayNamesShort:	 ['zo','ma','di','wo','do','vr','za'],
			dayNamesMin:	 ['zo','ma','di','wo','do','vr','za'],
			weekHeader:	 'wk',
			dateFormat: 'dd.mm.yy',
			firstDay: 1,
			isRTL: false,
			showMonthAfterYear: false,
			yearSuffix: ''};
	$.datepicker.regional['frfr'] = {
		closeText: 'Fermer',
		prevText: '&#x3c;Prc',
		nextText: 'Suiv&#x3e;',
		currentText: 'Courant',
		monthNames: ['Janvier','Fvrier','Mars','Avril','Mai','Juin','Juillet','Aot','Septembre','Octobre','Novembre','Dcembre'],
		monthNamesShort: ['janv.','fvr.','mars','avr.','mai','juin','juil.','aot','sept.','oct.','nov.','dc.'],
		dayNames: ['Dimanche','Lundi','Mardi','Mercredi','Jeudi','Vendredi','Samedi'],
		dayNamesShort: ['dim.','lun.','mar.','mer.','jeu.','ven.','sam.'],
		dayNamesMin: ['Di','Lu','Ma','Me','Je','Ve','Sa'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['gben'] = {
		closeText: 'Done',
		prevText: 'Prev',
		nextText: 'Next',
		currentText: 'Today',
		monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',	'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['itit'] = {
		closeText: 'Chiudi',
		prevText: '&#x3c;Prec',
		nextText: 'Succ&#x3e;',
		currentText: 'Oggi',
		monthNames: ['Gennaio','Febbraio','Marzo','Aprile','Maggio','Giugno','Luglio','Agosto','Settembre','Ottobre','Novembre','Dicembre'],
		monthNamesShort: ['gen','feb','mar','apr','mag','giu','lug','ago','set','ott','nov','dic'],
		dayNames: ['Domenica','Luned&#236','Marted&#236','Mercoled&#236','Gioved&#236','Venerd&#236','Sabato'],
		dayNamesShort: ['dom','lun','mar','mer','gio','ven','sab'],
		dayNamesMin: ['Do','Lu','Ma','Me','Gi','Ve','Sa'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['uses'] = {
		closeText: 'Cerrar',
		prevText: '&#x3c;Ant',
		nextText: 'Sig&#x3e;',
		currentText: 'Hoy',
		monthNames: ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'],
		monthNamesShort: ['ene','feb','mar','abr','may','jun','jul','ago','sep','oct','nov','dic'],
		dayNames: ['Domingo','Lunes','Martes','Mi&eacute;rcoles','Jueves','Viernes','S&aacute;bado'],
		dayNamesShort: ['dom','lun','mar','mi','jue','vie','sb'],
		dayNamesMin: ['Do','Lu','Ma','Mi','Ju','Vi','S&aacute;'],
		weekHeader: 'Sm',
		dateFormat: 'dd/mm/yy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['jpja'] = {
		closeText: '',
		prevText: '',
		nextText: '',
		currentText: '',
		monthNames: ['1','2','3','4','5','6','7','8','9','10','11','12'],
		monthNamesShort: ['1','2','3','4','5','6','7','8','9','10','11','12'],
		dayNames: ['','','','','','',''],
		dayNamesShort: ['','','','','','',''],
		dayNamesMin: ['','','','','','',''],
		weekHeader: '',
		dateFormat: 'yyyy/mm/dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['krko'] = {
		closeText: '',
		prevText: '',
		nextText: '',
		currentText: '',
		monthNames: ['01','02','03','04','05','06','07','08','09','10','11','12'],
		monthNamesShort: ['01', '02', '03', '04', '05', '06','07', '08', '09', '10', '11', '12'],
		dayNames: ['', '', '', '', '', '', ''],
		dayNamesShort: ['', '', '', '', '', '', ''],
		dayNamesMin: ['','','','','','',''],
		weekHeader: '',
		dateFormat: 'yy-mm-dd',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['ptpt'] = {
		closeText: 'feito',
		prevText: 'anterior',
		nextText: 'prxima',
		currentText: 'hoje',
		monthNames: ['Janeiro','Fevereiro','Maro','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],
		monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'],
		dayNames: ['Domingo','Segunda-feira','Tera-feira','Quarta-feira','Quinta-feira','Sexta-feira','Sbado'],
		dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','Sb'],
		dayNamesMin: ['Dom','Seg','Ter','Qua','Qui','Sex','Sb'],
		weekHeader: 'semana',
		dateFormat: 'dd/mm/yyyy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['aear'] = {
		closeText: '',
		prevText: '    .',
		nextText: '    .',
		currentText: '',
		monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
		monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
		dayNames: ['', '', '', '', '', '', ''],
		dayNamesShort: ['', '', '', '', '', '', ''],
		dayNamesMin: ['', '', '', '', '', '', ''],
		weekHeader: '',
		dateFormat: 'dd/mm/yyyy',
		firstDay: 6,
		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['iliw'] = {
		closeText: '',
		prevText: '&#x3c;  .',
		nextText: '  .&#x3e;',
		currentText: '',
		monthNames: ['','','','','','','','','','','',''],
		monthNamesShort: ['','','','','','','','','','','',''],
		dayNames: ['','','','','','',''],
		dayNamesShort: ['\'','\'','\'','\'','\'','\'',''],
		dayNamesMin: ['\'','\'','\'','\'','\'','\'',''],
		weekHeader: '',
		dateFormat: 'dd/mm/yyyy',
		firstDay: 0,
		isRTL: true,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.regional['trtr'] = {
		closeText: 'yakn', // Display text for close link
		prevText: 'nceki aya dnmek iin sein.', // Display text for previous month link
		nextText: 'Sonraki aya gitmek iin sein.', // Display text for next month link
		currentText: 'bugn', // Display text for current month link
		monthNames: ['Ocak','ubat','Mart','Nisan','Mays','Haziran','Temmuz','Austos','Eyll','Ekim','Kasm','Aralk'], // Names of months for drop-down and formatting
		monthNamesShort: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'], // Turkish Languaje : The following short months' names were changed (Ekm for Eki, Arl for Ara, Sb for Sub, Oc for Oca)
		dayNames: ['Pazar', 'Pazartesi', 'Sal', 'aramba', 'Perembe', 'Cuma', 'Cumartesi'], // For formatting
		dayNamesShort: ['Sun', 'Pzt', 'Sl', 'r', 'Pr', 'Cm', 'Cts'], // For formatting
		dayNamesMin: ['Sun','Pzt','Sl','r','Pr','Cm','Cts'], // Column headings for days starting at Sunday
		weekHeader: 'hafta', // Column header for week of the year
		dateFormat: 'dd/mm/yyyy', // See format options on parseDate
		firstDay: 1, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: ''}; // Additional text to append to the year in the month headers
	$.datepicker.regional['ruru'] = {
		closeText: '',
		prevText: '    ,  .',
		nextText: '    ,  .',
		currentText: '',
		monthNames: ['','','','','','','','','','','',''],
		monthNamesShort: ['', '', '', '', '', '',	'', '', '', '', '', ''],
		dayNames: ['', '', '', '', '', '', ''],
		dayNamesShort: ['', '', '', '', '', '', ''],
		dayNamesMin: ['','','','','','',''],
		weekHeader: 'Wk',
		dateFormat: 'dd/mm/yyyy',
		firstDay: 1,
		isRTL: false,
		showMonthAfterYear: false,
		yearSuffix: ''};
	$.datepicker.setDefaults($.datepicker.regional[CALENDAR_DATA.COUNTRY + CALENDAR_DATA.LANGUAGE]);
});
/**
 * @name MarkerClustererPlus for Google Maps V3
 * @version 2.1.1 [November 4, 2013]
 * @author Gary Little
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of markers.
 * <p>
 * This is an enhanced V3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the
 * <a href="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/"
 * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.
 * <p>
 * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It
 *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>batchSizeIE</code>,
 *  and <code>calculator</code> properties as well as support for four more events. It also allows
 *  greater control over the styling of the text that appears on the cluster marker. The
 *  documentation has been significantly improved and the overall code has been simplified and
 *  polished. Very large numbers of markers can now be managed without causing Javascript timeout
 *  errors on Internet Explorer. Note that the name of the <code>clusterclick</code> event has been
 *  deprecated. The new name is <code>click</code>, so please change your application code now.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @name ClusterIconStyle
 * @class This class represents the object for values in the <code>styles</code> array passed
 *  to the {@link MarkerClusterer} constructor. The element in this array that is used to
 *  style the cluster icon is determined by calling the <code>calculator</code> function.
 *
 * @property {string} url The URL of the cluster icon image file. Required.
 * @property {number} height The display height (in pixels) of the cluster icon. Required.
 * @property {number} width The display width (in pixels) of the cluster icon. Required.
 * @property {Array} [anchorText] The position (in pixels) from the center of the cluster icon to
 *  where the text label is to be centered and drawn. The format is <code>[yoffset, xoffset]</code>
 *  where <code>yoffset</code> increases as you go down from center and <code>xoffset</code>
 *  increases to the right of center. The default is <code>[0, 0]</code>.
 * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the
 *  spot on the cluster icon that is to be aligned with the cluster position. The format is
 *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and
 *  <code>xoffset</code> increases to the right of the top-left corner of the icon. The default
 *  anchor position is the center of the cluster icon.
 * @property {string} [textColor="black"] The color of the label text shown on the
 *  cluster icon.
 * @property {number} [textSize=11] The size (in pixels) of the label text shown on the
 *  cluster icon.
 * @property {string} [textDecoration="none"] The value of the CSS <code>text-decoration</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontWeight="bold"] The value of the CSS <code>font-weight</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontStyle="normal"] The value of the CSS <code>font-style</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontFamily="Arial,sans-serif"] The value of the CSS <code>font-family</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [backgroundPosition="0 0"] The position of the cluster icon image
 *  within the image defined by <code>url</code>. The format is <code>"xpos ypos"</code>
 *  (the same format as for the CSS <code>background-position</code> property). You must set
 *  this property appropriately when the image defined by <code>url</code> represents a sprite
 *  containing multiple images. Note that the position <i>must</i> be specified in px units.
 */
/**
 * @name ClusterIconInfo
 * @class This class is an object containing general information about a cluster icon. This is
 *  the object that a <code>calculator</code> function returns.
 *
 * @property {string} text The text of the label to be shown on the cluster icon.
 * @property {number} index The index plus 1 of the element in the <code>styles</code>
 *  array to be used to style the cluster icon.
 * @property {string} title The tooltip to display when the mouse moves over the cluster icon.
 *  If this value is <code>undefined</code> or <code>""</code>, <code>title</code> is set to the
 *  value of the <code>title</code> property passed to the MarkerClusterer.
 */
/**
 * A cluster icon.
 *
 * @constructor
 * @extends google.maps.OverlayView
 * @param {Cluster} cluster The cluster with which the icon is to be associated.
 * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons
 *  to use for various cluster sizes.
 * @private
 */
function ClusterIcon(cluster, styles) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.cluster_ = cluster;
  this.className_ = cluster.getMarkerClusterer().getClusterClass();
  this.styles_ = styles;
  this.center_ = null;
  this.div_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(cluster.getMap()); // Note: this causes onAdd to be called
}


/**
 * Adds the icon to the DOM.
 */
ClusterIcon.prototype.onAdd = function () {
  var cClusterIcon = this;
  var cMouseDownInCluster;
  var cDraggingMapByCluster;

  this.div_ = document.createElement("div");
  this.div_.className = this.className_;
  if (this.visible_) {
    this.show();
  }

  this.getPanes().overlayMouseTarget.appendChild(this.div_);

  // Fix for Issue 157
  this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function () {
    cDraggingMapByCluster = cMouseDownInCluster;
  });

  google.maps.event.addDomListener(this.div_, "mousedown", function () {
    cMouseDownInCluster = true;
    cDraggingMapByCluster = false;
  });

  google.maps.event.addDomListener(this.div_, "click", function (e) {
    cMouseDownInCluster = false;
    if (!cDraggingMapByCluster) {
      var theBounds;
      var mz;
      var mc = cClusterIcon.cluster_.getMarkerClusterer();
      /**
       * This event is fired when a cluster marker is clicked.
       * @name MarkerClusterer#click
       * @param {Cluster} c The cluster that was clicked.
       * @event
       */
      google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
      google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_); // deprecated name

      // The default click handler follows. Disable it by setting
      // the zoomOnClick property to false.
      if (mc.getZoomOnClick()) {
        // Zoom into the cluster.
        mz = mc.getMaxZoom();
        theBounds = cClusterIcon.cluster_.getBounds();
        mc.getMap().fitBounds(theBounds);
        // There is a fix for Issue 170 here:
        setTimeout(function () {
          mc.getMap().fitBounds(theBounds);
          // Don't zoom beyond the max zoom level
          if (mz !== null && (mc.getMap().getZoom() > mz)) {
            mc.getMap().setZoom(mz + 1);
          }
        }, 100);
      }

      // Prevent event propagation to the map:
      e.cancelBubble = true;
      if (e.stopPropagation) {
        e.stopPropagation();
      }
    }
  });

  google.maps.event.addDomListener(this.div_, "mouseover", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves over a cluster marker.
     * @name MarkerClusterer#mouseover
     * @param {Cluster} c The cluster that the mouse moved over.
     * @event
     */
    google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
  });

  google.maps.event.addDomListener(this.div_, "mouseout", function () {
    var mc = cClusterIcon.cluster_.getMarkerClusterer();
    /**
     * This event is fired when the mouse moves out of a cluster marker.
     * @name MarkerClusterer#mouseout
     * @param {Cluster} c The cluster that the mouse moved out of.
     * @event
     */
    google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
  });
};


/**
 * Removes the icon from the DOM.
 */
ClusterIcon.prototype.onRemove = function () {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    google.maps.event.removeListener(this.boundsChangedListener_);
    google.maps.event.clearInstanceListeners(this.div_);
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};


/**
 * Draws the icon.
 */
ClusterIcon.prototype.draw = function () {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + "px";
    this.div_.style.left = pos.x + "px";
  }
};


/**
 * Hides the icon.
 */
ClusterIcon.prototype.hide = function () {
  if (this.div_) {
    this.div_.style.display = "none";
  }
  this.visible_ = false;
};


/**
 * Positions and shows the icon.
 */
ClusterIcon.prototype.show = function () {
  if (this.div_) {
    var img = "";
    // NOTE: values must be specified in px units
    var bp = this.backgroundPosition_.split(" ");
    var spriteH = parseInt(bp[0].trim(), 10);
    var spriteV = parseInt(bp[1].trim(), 10);
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
    if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
      img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " +
          ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
    }
    img += "'>";
    this.div_.innerHTML = img + "<div style='" +
        "position: absolute;" +
        "top: " + this.anchorText_[0] + "px;" +
        "left: " + this.anchorText_[1] + "px;" +
        "color: " + this.textColor_ + ";" +
        "font-size: " + this.textSize_ + "px;" +
        "font-family: " + this.fontFamily_ + ";" +
        "font-weight: " + this.fontWeight_ + ";" +
        "font-style: " + this.fontStyle_ + ";" +
        "text-decoration: " + this.textDecoration_ + ";" +
        "text-align: center;" +
        "width: " + this.width_ + "px;" +
        "line-height:" + this.height_ + "px;" +
        "'>" + this.sums_.text + "</div>";
    if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
      this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
    } else {
      this.div_.title = this.sums_.title;
    }
    this.div_.style.display = "";
  }
  this.visible_ = true;
};


/**
 * Sets the icon styles to the appropriate element in the styles array.
 *
 * @param {ClusterIconInfo} sums The icon label text and styles index.
 */
ClusterIcon.prototype.useStyle = function (sums) {
  this.sums_ = sums;
  var index = Math.max(0, sums.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style.url;
  this.height_ = style.height;
  this.width_ = style.width;
  this.anchorText_ = style.anchorText || [0, 0];
  this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];
  this.textColor_ = style.textColor || "black";
  this.textSize_ = style.textSize || 11;
  this.textDecoration_ = style.textDecoration || "none";
  this.fontWeight_ = style.fontWeight || "bold";
  this.fontStyle_ = style.fontStyle || "normal";
  this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
  this.backgroundPosition_ = style.backgroundPosition || "0 0";
};


/**
 * Sets the position at which to center the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function (center) {
  this.center_ = center;
};


/**
 * Creates the cssText style parameter based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position of the icon.
 * @return {string} The CSS style text.
 */
ClusterIcon.prototype.createCss = function (pos) {
  var style = [];
  style.push("cursor: pointer;");
  style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
  style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
  return style.join("");
};


/**
 * Returns the position at which to place the DIV depending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 */
ClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
  pos.x -= this.anchorIcon_[1];
  pos.y -= this.anchorIcon_[0];
  pos.x = parseInt(pos.x, 10);
  pos.y = parseInt(pos.y, 10);
  return pos;
};


/**
 * Creates a single cluster that manages a group of proximate markers.
 *  Used internally, do not call this constructor directly.
 * @constructor
 * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this
 *  cluster is associated.
 */
function Cluster(mc) {
  this.markerClusterer_ = mc;
  this.map_ = mc.getMap();
  this.gridSize_ = mc.getGridSize();
  this.minClusterSize_ = mc.getMinimumClusterSize();
  this.averageCenter_ = mc.getAverageCenter();
  this.markers_ = [];
  this.center_ = null;
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
}


/**
 * Returns the number of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {number} The number of markers in the cluster.
 */
Cluster.prototype.getSize = function () {
  return this.markers_.length;
};


/**
 * Returns the array of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {Array} The array of markers in the cluster.
 */
Cluster.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 * Returns the center of the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {google.maps.LatLng} The center of the cluster.
 */
Cluster.prototype.getCenter = function () {
  return this.center_;
};


/**
 * Returns the map with which the cluster is associated.
 *
 * @return {google.maps.Map} The map.
 * @ignore
 */
Cluster.prototype.getMap = function () {
  return this.map_;
};


/**
 * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 * @ignore
 */
Cluster.prototype.getMarkerClusterer = function () {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 * @ignore
 */
Cluster.prototype.getBounds = function () {
  var i;
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster from the map.
 *
 * @ignore
 */
Cluster.prototype.remove = function () {
  this.clusterIcon_.setMap(null);
  this.markers_ = [];
  delete this.markers_;
};


/**
 * Adds a marker to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to be added.
 * @return {boolean} True if the marker was added.
 * @ignore
 */
Cluster.prototype.addMarker = function (marker) {
  var i;
  var mCount;
  var mz;

  if (this.isMarkerAlreadyAdded_(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  mCount = this.markers_.length;
  mz = this.markerClusterer_.getMaxZoom();
  if (mz !== null && this.map_.getZoom() > mz) {
    // Zoomed in past max zoom, so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount < this.minClusterSize_) {
    // Min cluster size not reached so show the marker.
    if (marker.getMap() !== this.map_) {
      marker.setMap(this.map_);
    }
  } else if (mCount === this.minClusterSize_) {
    // Hide the markers that were showing.
    for (i = 0; i < mCount; i++) {
      this.markers_[i].setMap(null);
    }
  } else {
    marker.setMap(null);
  }

  this.updateIcon_();
  return true;
};


/**
 * Determines if a marker lies within the cluster's bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 * @ignore
 */
Cluster.prototype.isMarkerInClusterBounds = function (marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Calculates the extended bounds of the cluster with the grid.
 */
Cluster.prototype.calculateBounds_ = function () {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Updates the cluster icon.
 */
Cluster.prototype.updateIcon_ = function () {
  var mCount = this.markers_.length;
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz !== null && this.map_.getZoom() > mz) {
    this.clusterIcon_.hide();
    return;
  }

  if (mCount < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.useStyle(sums);
  this.clusterIcon_.show();
};


/**
 * Determines if a marker has already been added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker has already been added.
 */
Cluster.prototype.isMarkerAlreadyAdded_ = function (marker) {
  var i;
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) !== -1;
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        return true;
      }
    }
  }
  return false;
};


/**
 * @name MarkerClustererOptions
 * @class This class represents the optional parameter passed to
 *  the {@link MarkerClusterer} constructor.
 * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.
 * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or
 *  <code>null</code> if clustering is to be enabled at all zoom levels.
 * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is
 *  clicked. You may want to set this to <code>false</code> if you have installed a handler
 *  for the <code>click</code> event and it deals with zooming on its own.
 * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be
 *  the average position of all markers in the cluster. If set to <code>false</code>, the
 *  cluster marker is positioned at the location of the first marker added to the cluster.
 * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster
 *  before the markers are hidden and a cluster marker appears.
 * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You
 *  may want to set this to <code>true</code> to ensure that hidden markers are not included
 *  in the marker count that appears on a cluster marker (this count is the value of the
 *  <code>text</code> property of the result returned by the default <code>calculator</code>).
 *  If set to <code>true</code> and you change the visibility of a marker being clustered, be
 *  sure to also call <code>MarkerClusterer.repaint()</code>.
 * @property {string} [title=""] The tooltip to display when the mouse moves over a cluster
 *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a
 *  different tooltip for each cluster marker.)
 * @property {function} [calculator=MarkerClusterer.CALCULATOR] The function used to determine
 *  the text to be displayed on a cluster marker and the index indicating which style to use
 *  for the cluster marker. The input parameters for the function are (1) the array of markers
 *  represented by a cluster marker and (2) the number of cluster icon styles. It returns a
 *  {@link ClusterIconInfo} object. The default <code>calculator</code> returns a
 *  <code>text</code> property which is the number of markers in the cluster and an
 *  <code>index</code> property which is one higher than the lowest integer such that
 *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles
 *  array, whichever is less. The <code>styles</code> array element used has an index of
 *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a
 *  <code>text</code> value of <code>"125"</code> and an <code>index</code> of <code>3</code>
 *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>
 *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>
 *  property that contains the text of the tooltip to be used for the cluster marker. If
 *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>
 *   property for the MarkerClusterer.
 * @property {string} [clusterClass="cluster"] The name of the CSS class defining general styles
 *  for the cluster markers. Use this class to define CSS styles that are not set up by the code
 *  that processes the <code>styles</code> array.
 * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles
 *  of the cluster markers to be used. The element to be used to style a given cluster marker
 *  is determined by the function defined by the <code>calculator</code> property.
 *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived
 *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and
 *  <code>imageSizes</code>.
 * @property {boolean} [enableRetinaIcons=false] Whether to allow the use of cluster icons that
 * have sizes that are some multiple (typically double) of their actual display size. Icons such
 * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.
 * Note: if this property is <code>true</code>, sprites cannot be used as cluster icons.
 * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the
 *  number of markers to be processed in a single batch when using a browser other than
 *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).
 * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is
 *  being used, markers are processed in several batches with a small delay inserted between
 *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the
 *  number of markers to be processed in a single batch; select as high a number as you can
 *  without causing a timeout error in the browser. This number might need to be as low as 100
 *  if 15,000 markers are being managed, for example.
 * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]
 *  The full URL of the root name of the group of image files to use for cluster icons.
 *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>
 *  where n is the image file number (1, 2, etc.).
 * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]
 *  The extension name for the cluster icon image files (e.g., <code>"png"</code> or
 *  <code>"jpg"</code>).
 * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]
 *  An array of numbers containing the widths of the group of
 *  <code>imagePath</code>n.<code>imageExtension</code> image files.
 *  (The images are assumed to be square.)
 */
/**
 * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.
 * @param {MarkerClustererOptions} [opt_options] The optional parameters.
 */
function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);

  opt_markers = opt_markers || [];
  opt_options = opt_options || {};

  this.markers_ = [];
  this.clusters_ = [];
  this.listeners_ = [];
  this.activeMap_ = null;
  this.ready_ = false;

  this.gridSize_ = opt_options.gridSize || 60;
  this.minClusterSize_ = opt_options.minimumClusterSize || 2;
  this.maxZoom_ = opt_options.maxZoom || null;
  this.styles_ = opt_options.styles || [];
  this.title_ = opt_options.title || "";
  this.zoomOnClick_ = true;
  if (opt_options.zoomOnClick !== undefined) {
    this.zoomOnClick_ = opt_options.zoomOnClick;
  }
  this.averageCenter_ = false;
  if (opt_options.averageCenter !== undefined) {
    this.averageCenter_ = opt_options.averageCenter;
  }
  this.ignoreHidden_ = false;
  if (opt_options.ignoreHidden !== undefined) {
    this.ignoreHidden_ = opt_options.ignoreHidden;
  }
  this.enableRetinaIcons_ = false;
  if (opt_options.enableRetinaIcons !== undefined) {
    this.enableRetinaIcons_ = opt_options.enableRetinaIcons;
  }
  this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
  this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
  this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
  this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
  this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
  this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
  this.clusterClass_ = opt_options.clusterClass || "cluster";

  if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
    // Try to avoid IE timeout when processing a huge number of markers:
    this.batchSize_ = this.batchSizeIE_;
  }

  this.setupStyles_();

  this.addMarkers(opt_markers, true);
  this.setMap(map); // Note: this causes onAdd to be called
}


/**
 * Implementation of the onAdd interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function () {
  var cMarkerClusterer = this;

  this.activeMap_ = this.getMap();
  this.ready_ = true;

  this.repaint();

  // Add the map event listeners
  this.listeners_ = [
    google.maps.event.addListener(this.getMap(), "zoom_changed", function () {
      cMarkerClusterer.resetViewport_(false);
      // Workaround for this Google bug: when map is at level 0 and "-" of
      // zoom slider is clicked, a "zoom_changed" event is fired even though
      // the map doesn't zoom out any further. In this situation, no "idle"
      // event is triggered so the cluster markers that have been removed
      // do not get redrawn. Same goes for a zoom in at maxZoom.
      if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
        google.maps.event.trigger(this, "idle");
      }
    }),
    google.maps.event.addListener(this.getMap(), "idle", function () {
      cMarkerClusterer.redraw_();
    })
  ];
};


/**
 * Implementation of the onRemove interface method.
 * Removes map event listeners and all cluster icons from the DOM.
 * All managed markers are also put back on the map.
 * @ignore
 */
MarkerClusterer.prototype.onRemove = function () {
  var i;

  // Put all the managed markers back on the map:
  for (i = 0; i < this.markers_.length; i++) {
    if (this.markers_[i].getMap() !== this.activeMap_) {
      this.markers_[i].setMap(this.activeMap_);
    }
  }

  // Remove all clusters:
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Remove map event listeners:
  for (i = 0; i < this.listeners_.length; i++) {
    google.maps.event.removeListener(this.listeners_[i]);
  }
  this.listeners_ = [];

  this.activeMap_ = null;
  this.ready_ = false;
};


/**
 * Implementation of the draw interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function () {};


/**
 * Sets up the styles object.
 */
MarkerClusterer.prototype.setupStyles_ = function () {
  var i, size;
  if (this.styles_.length > 0) {
    return;
  }

  for (i = 0; i < this.imageSizes_.length; i++) {
    size = this.imageSizes_[i];
    this.styles_.push({
      url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
      height: size,
      width: size
    });
  }
};


/**
 *  Fits the map to the bounds of the markers managed by the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function () {
  var i;
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (i = 0; i < markers.length; i++) {
    bounds.extend(markers[i].getPosition());
  }

  this.getMap().fitBounds(bounds);
};


/**
 * Returns the value of the <code>gridSize</code> property.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function () {
  return this.gridSize_;
};


/**
 * Sets the value of the <code>gridSize</code> property.
 *
 * @param {number} gridSize The grid size.
 */
MarkerClusterer.prototype.setGridSize = function (gridSize) {
  this.gridSize_ = gridSize;
};


/**
 * Returns the value of the <code>minimumClusterSize</code> property.
 *
 * @return {number} The minimum cluster size.
 */
MarkerClusterer.prototype.getMinimumClusterSize = function () {
  return this.minClusterSize_;
};

/**
 * Sets the value of the <code>minimumClusterSize</code> property.
 *
 * @param {number} minimumClusterSize The minimum cluster size.
 */
MarkerClusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {
  this.minClusterSize_ = minimumClusterSize;
};


/**
 *  Returns the value of the <code>maxZoom</code> property.
 *
 *  @return {number} The maximum zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function () {
  return this.maxZoom_;
};


/**
 *  Sets the value of the <code>maxZoom</code> property.
 *
 *  @param {number} maxZoom The maximum zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function (maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Returns the value of the <code>styles</code> property.
 *
 *  @return {Array} The array of styles defining the cluster markers to be used.
 */
MarkerClusterer.prototype.getStyles = function () {
  return this.styles_;
};


/**
 *  Sets the value of the <code>styles</code> property.
 *
 *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.
 */
MarkerClusterer.prototype.setStyles = function (styles) {
  this.styles_ = styles;
};


/**
 * Returns the value of the <code>title</code> property.
 *
 * @return {string} The content of the title text.
 */
MarkerClusterer.prototype.getTitle = function () {
  return this.title_;
};


/**
 *  Sets the value of the <code>title</code> property.
 *
 *  @param {string} title The value of the title property.
 */
MarkerClusterer.prototype.setTitle = function (title) {
  this.title_ = title;
};


/**
 * Returns the value of the <code>zoomOnClick</code> property.
 *
 * @return {boolean} True if zoomOnClick property is set.
 */
MarkerClusterer.prototype.getZoomOnClick = function () {
  return this.zoomOnClick_;
};


/**
 *  Sets the value of the <code>zoomOnClick</code> property.
 *
 *  @param {boolean} zoomOnClick The value of the zoomOnClick property.
 */
MarkerClusterer.prototype.setZoomOnClick = function (zoomOnClick) {
  this.zoomOnClick_ = zoomOnClick;
};


/**
 * Returns the value of the <code>averageCenter</code> property.
 *
 * @return {boolean} True if averageCenter property is set.
 */
MarkerClusterer.prototype.getAverageCenter = function () {
  return this.averageCenter_;
};


/**
 *  Sets the value of the <code>averageCenter</code> property.
 *
 *  @param {boolean} averageCenter The value of the averageCenter property.
 */
MarkerClusterer.prototype.setAverageCenter = function (averageCenter) {
  this.averageCenter_ = averageCenter;
};


/**
 * Returns the value of the <code>ignoreHidden</code> property.
 *
 * @return {boolean} True if ignoreHidden property is set.
 */
MarkerClusterer.prototype.getIgnoreHidden = function () {
  return this.ignoreHidden_;
};


/**
 *  Sets the value of the <code>ignoreHidden</code> property.
 *
 *  @param {boolean} ignoreHidden The value of the ignoreHidden property.
 */
MarkerClusterer.prototype.setIgnoreHidden = function (ignoreHidden) {
  this.ignoreHidden_ = ignoreHidden;
};


/**
 * Returns the value of the <code>enableRetinaIcons</code> property.
 *
 * @return {boolean} True if enableRetinaIcons property is set.
 */
MarkerClusterer.prototype.getEnableRetinaIcons = function () {
  return this.enableRetinaIcons_;
};


/**
 *  Sets the value of the <code>enableRetinaIcons</code> property.
 *
 *  @param {boolean} enableRetinaIcons The value of the enableRetinaIcons property.
 */
MarkerClusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {
  this.enableRetinaIcons_ = enableRetinaIcons;
};


/**
 * Returns the value of the <code>imageExtension</code> property.
 *
 * @return {string} The value of the imageExtension property.
 */
MarkerClusterer.prototype.getImageExtension = function () {
  return this.imageExtension_;
};


/**
 *  Sets the value of the <code>imageExtension</code> property.
 *
 *  @param {string} imageExtension The value of the imageExtension property.
 */
MarkerClusterer.prototype.setImageExtension = function (imageExtension) {
  this.imageExtension_ = imageExtension;
};


/**
 * Returns the value of the <code>imagePath</code> property.
 *
 * @return {string} The value of the imagePath property.
 */
MarkerClusterer.prototype.getImagePath = function () {
  return this.imagePath_;
};


/**
 *  Sets the value of the <code>imagePath</code> property.
 *
 *  @param {string} imagePath The value of the imagePath property.
 */
MarkerClusterer.prototype.setImagePath = function (imagePath) {
  this.imagePath_ = imagePath;
};


/**
 * Returns the value of the <code>imageSizes</code> property.
 *
 * @return {Array} The value of the imageSizes property.
 */
MarkerClusterer.prototype.getImageSizes = function () {
  return this.imageSizes_;
};


/**
 *  Sets the value of the <code>imageSizes</code> property.
 *
 *  @param {Array} imageSizes The value of the imageSizes property.
 */
MarkerClusterer.prototype.setImageSizes = function (imageSizes) {
  this.imageSizes_ = imageSizes;
};


/**
 * Returns the value of the <code>calculator</code> property.
 *
 * @return {function} the value of the calculator property.
 */
MarkerClusterer.prototype.getCalculator = function () {
  return this.calculator_;
};


/**
 * Sets the value of the <code>calculator</code> property.
 *
 * @param {function(Array.<google.maps.Marker>, number)} calculator The value
 *  of the calculator property.
 */
MarkerClusterer.prototype.setCalculator = function (calculator) {
  this.calculator_ = calculator;
};


/**
 * Returns the value of the <code>batchSizeIE</code> property.
 *
 * @return {number} the value of the batchSizeIE property.
 */
MarkerClusterer.prototype.getBatchSizeIE = function () {
  return this.batchSizeIE_;
};


/**
 * Sets the value of the <code>batchSizeIE</code> property.
 *
 *  @param {number} batchSizeIE The value of the batchSizeIE property.
 */
MarkerClusterer.prototype.setBatchSizeIE = function (batchSizeIE) {
  this.batchSizeIE_ = batchSizeIE;
};


/**
 * Returns the value of the <code>clusterClass</code> property.
 *
 * @return {string} the value of the clusterClass property.
 */
MarkerClusterer.prototype.getClusterClass = function () {
  return this.clusterClass_;
};


/**
 * Sets the value of the <code>clusterClass</code> property.
 *
 *  @param {string} clusterClass The value of the clusterClass property.
 */
MarkerClusterer.prototype.setClusterClass = function (clusterClass) {
  this.clusterClass_ = clusterClass;
};


/**
 *  Returns the array of markers managed by the clusterer.
 *
 *  @return {Array} The array of markers managed by the clusterer.
 */
MarkerClusterer.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 *  Returns the number of markers managed by the clusterer.
 *
 *  @return {number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function () {
  return this.markers_.length;
};


/**
 * Returns the current array of clusters formed by the clusterer.
 *
 * @return {Array} The array of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getClusters = function () {
  return this.clusters_;
};


/**
 * Returns the number of clusters formed by the clusterer.
 *
 * @return {number} The number of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getTotalClusters = function () {
  return this.clusters_.length;
};


/**
 * Adds a marker to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Adds an array of markers to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {
  var key;
  for (key in markers) {
    if (markers.hasOwnProperty(key)) {
      this.pushMarkerTo_(markers[key]);
    }
  }  
  if (!opt_nodraw) {
    this.redraw_();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.pushMarkerTo_ = function (marker) {
  // If the marker is draggable add a listener so we can update the clusters on the dragend:
  if (marker.getDraggable()) {
    var cMarkerClusterer = this;
    google.maps.event.addListener(marker, "dragend", function () {
      if (cMarkerClusterer.ready_) {
        this.isAdded = false;
        cMarkerClusterer.repaint();
      }
    });
  }
  marker.isAdded = false;
  this.markers_.push(marker);
};


/**
 * Removes a marker from the cluster.  The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the
 *  marker was removed from the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if the marker was removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes an array of markers from the cluster. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers
 *  were removed from the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if markers were removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {
  var i, r;
  var removed = false;

  for (i = 0; i < markers.length; i++) {
    r = this.removeMarker_(markers[i]);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.repaint();
  }

  return removed;
};


/**
 * Removes a marker and returns true if removed, false if not.
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 */
MarkerClusterer.prototype.removeMarker_ = function (marker) {
  var i;
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (i = 0; i < this.markers_.length; i++) {
      if (marker === this.markers_[i]) {
        index = i;
        break;
      }
    }
  }

  if (index === -1) {
    // Marker is not in our list of markers, so do nothing:
    return false;
  }

  marker.setMap(null);
  this.markers_.splice(index, 1); // Remove the marker from the list of managed markers
  return true;
};


/**
 * Removes all clusters and markers from the map and also removes all markers
 *  managed by the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function () {
  this.resetViewport_(true);
  this.markers_ = [];
};


/**
 * Recalculates and redraws all the marker clusters from scratch.
 *  Call this after changing any properties.
 */
MarkerClusterer.prototype.repaint = function () {
  var oldClusters = this.clusters_.slice();
  this.clusters_ = [];
  this.resetViewport_(false);
  this.redraw_();

  // Remove the old clusters.
  // Do it in a timeout to prevent blinking effect.
  setTimeout(function () {
    var i;
    for (i = 0; i < oldClusters.length; i++) {
      oldClusters[i].remove();
    }
  }, 0);
};


/**
 * Returns the current bounds extended by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 * @ignore
 */
MarkerClusterer.prototype.getExtendedBounds = function (bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Redraws all the clusters.
 */
MarkerClusterer.prototype.redraw_ = function () {
  this.createClusters_(0);
};


/**
 * Removes all clusters from the map. The markers are also removed from the map
 *  if <code>opt_hide</code> is set to <code>true</code>.
 *
 * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
 *  from the map.
 */
MarkerClusterer.prototype.resetViewport_ = function (opt_hide) {
  var i, marker;
  // Remove all the clusters
  for (i = 0; i < this.clusters_.length; i++) {
    this.clusters_[i].remove();
  }
  this.clusters_ = [];

  // Reset the markers to not be added and to be removed from the map.
  for (i = 0; i < this.markers_.length; i++) {
    marker = this.markers_[i];
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }
};


/**
 * Calculates the distance between two latlng locations in km.
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {
  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Determines if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Adds a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.addToClosestCluster_ = function (marker) {
  var i, d, cluster, center;
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  for (i = 0; i < this.clusters_.length; i++) {
    cluster = this.clusters_[i];
    center = cluster.getCenter();
    if (center) {
      d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters. This is done in batches to avoid timeout errors
 *  in some browsers when there is a huge number of markers.
 *
 * @param {number} iFirst The index of the first marker in the batch of
 *  markers to be added to clusters.
 */
MarkerClusterer.prototype.createClusters_ = function (iFirst) {
  var i, marker;
  var mapBounds;
  var cMarkerClusterer = this;
  if (!this.ready_) {
    return;
  }

  // Cancel previous batch processing if we're working on the first batch:
  if (iFirst === 0) {
    /**
     * This event is fired when the <code>MarkerClusterer</code> begins
     *  clustering markers.
     * @name MarkerClusterer#clusteringbegin
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringbegin", this);

    if (typeof this.timerRefStatic !== "undefined") {
      clearTimeout(this.timerRefStatic);
      delete this.timerRefStatic;
    }
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  //
  // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
  if (this.getMap().getZoom() > 3) {
    mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),
      this.getMap().getBounds().getNorthEast());
  } else {
    mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
  }
  var bounds = this.getExtendedBounds(mapBounds);

  var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);

  for (i = iFirst; i < iLast; i++) {
    marker = this.markers_[i];
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
        this.addToClosestCluster_(marker);
      }
    }
  }

  if (iLast < this.markers_.length) {
    this.timerRefStatic = setTimeout(function () {
      cMarkerClusterer.createClusters_(iLast);
    }, 0);
  } else {
    delete this.timerRefStatic;

    /**
     * This event is fired when the <code>MarkerClusterer</code> stops
     *  clustering markers.
     * @name MarkerClusterer#clusteringend
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
    google.maps.event.trigger(this, "clusteringend", this);
  }
};


/**
 * Extends an object's prototype by another's.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function (obj1, obj2) {
  return (function (object) {
    var property;
    for (property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * The default function for determining the label text and style
 * for a cluster icon.
 *
 * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.
 * @param {number} numStyles The number of marker styles available.
 * @return {ClusterIconInfo} The information resource for the cluster.
 * @constant
 * @ignore
 */
MarkerClusterer.CALCULATOR = function (markers, numStyles) {
  var index = 0;
  var title = "";
  var count = markers.length.toString();

  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
// TODO: The text below needs translations, if ever used!!!
//  text: "+" + count + " More Hotels...",
    text: "",
    index: index,
    title: title 
  };
};


/**
 * The number of markers to process in one batch.
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE = 2000;


/**
 * The number of markers to process in one batch (IE only).
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE_IE = 500;


/**
 * The default root name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";


/**
 * The default extension name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_EXTENSION = "png";


/**
 * The default array of sizes for the marker cluster images.
 *
 * @type {Array.<number>}
 * @constant
 */
MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];

if (typeof String.prototype.trim !== 'function') {
  /**
   * IE hack since trim() doesn't exist in all browsers
   * @return {string} The string with removed whitespace
   */
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, ''); 
  }
}

var LocationSearch = function() {
	var CHARS_SHORT = 3;
	var CHARS_MAX= 75;

	var SHORT_DELAY = 10;
	var LONG_DELAY = 400;

	var isRecentSearch = false,
		hasHotels = false;

	// hold the translated messages here in a map
	var translations = new Object();

	function categoryLabel(item) {
		return translations["suggestive." + categoryClass(item)];
	}
	
	function categoryClass(item) {
		return (item.destinationType == "HOTEL_NAME") ? "hotel" : "city";
	}
	
	function renderHeadings(ul, item) {
		if (isRecentSearch && $(ul).find("li").length == 0) {
			$('<li class="recentSearchHeader"></li>')
				.append(translations["suggestive.recent"])
				.appendTo(ul);
			
		} else if (hasHotels && $(ul).find('li.' + categoryClass(item)).length == 0) {
			$("<li class=\"ui-autocomplete-category\"></li>")
				.addClass(categoryClass(item))
				.append(categoryLabel(item))
				.appendTo(ul);
		}
	}
	
	var customRenderer = function(ul, item) {			
		var $autoCompleteElement = $("<li></li>")
			.addClass(item.destinationType.toLowerCase())
			.data('ui-autocomplete-item', item);
		
		renderHeadings(ul, item);

		if (isRecentSearch && item.checkInDate && item.checkOutDate) {
			// Recent Search with Dates
			$autoCompleteElement.append('<a>' + item.label + '<span class="recentSearchDates">' + item.checkInDate + ' ' + translations["suggestive.to"] + ' ' + item.checkOutDate + '</span></a>');
		} else {
			// Recent Search without Dates + All other Suggestive Text scenarios
			$autoCompleteElement.append('<a>' + item.label + '</a>');
		}

		return $autoCompleteElement.appendTo(ul);
	};

	function initialize() {
		$("#ctlDest, #ctlStart, #ctlEnd").keydown(function(){		
			if($(this).val().length >= CHARS_SHORT) {
				$(this).autocomplete("option","delay", LONG_DELAY);			
			} else {
				$(this).autocomplete("option","delay", SHORT_DELAY);
			}
		});
		
		$("#ctlDest, #ctlStart, #ctlEnd").click(function(){
			if($(this).val().length == 0) {
				$(this).autocomplete("search", "");
			}
		});

        //Reset the coordinates for the clarify search on SearchResult
        $('#ctlDest').keypress(function(){
            jQuery('#latitude').val("0.0");
            jQuery('#longitude').val("0.0");
        });

		$("#ctlDest, #ctlStart, #ctlEnd").autocomplete({
			source: function(request, response) {
				$.ajaxSetup({ cache: false });
				$.getJSON(window.location.pathname+ "/locate", {query: request.term}, function(data) {
					isRecentSearch = data.payload.recentSearch;
					hasHotels = data.payload.hotelResult;
					
					translations["suggestive.to"] = data.payload.translations.suggestive_to;
					translations["suggestive.recent"] = data.payload.translations.suggestive_recent;
					translations["suggestive.city"] = data.payload.translations.suggestive_city;
					translations["suggestive.hotel"] = data.payload.translations.suggestive_hotel;
					
					response(data.payload.filteredSuggestionList);
				});
			},
			minLength: 0,
			delay: SHORT_DELAY,
			change: function(event, ui) {
				if (!ui) {
					return;
				}
				if (ui.item && ui.item.value && ui.item.value.length > CHARS_MAX) {
					$("#ctlDest").val(ui.item.value.substr(0, CHARS_MAX));
				}
			},
			select: function(event, ui) {
				if(ui.item.destinationType == "RECENT_SEARCH") {
					if (SERVER_VARIABLES.isAlongRoute) {
						if (ui.item.checkInDate && ui.item.checkOutDate) {
							$("#checkInDate").val(ui.item.checkInDate);
							$("#checkOutDate").val(ui.item.checkOutDate);
						}
					} else {
					showBusySpinner('#busySpinner');
					window.location.href = ui.item.linkUrl;
					}
				} else {
					if (categoryClass(ui.item) == "hotel") {
						$("#hotelcode").val(ui.item.hotelMnemonic);
					} else {
						$("#hotelcode").val("");
					}
					
					$("#latitude").val(ui.item.latitude);
					$("#longitude").val(ui.item.longitude);
					
					if (ui.item && ui.item.value.length > CHARS_MAX) {
						$(this).val(ui.item.value.substr(0, CHARS_MAX));
					}					
				}
			}
		});

		if ($("#ctlDest").length > 0){
			$("#ctlDest").data("ui-autocomplete")._renderItem = customRenderer;
		}
		
		if ($("#ctlStart").length > 0 && $("#ctlEnd").length > 0){
			$('#ctlStart').data('ui-autocomplete')._renderItem = customRenderer;
			$('#ctlEnd').data('ui-autocomplete')._renderItem = customRenderer;
		}
	}

	// Show the busy spinner.
	function showBusySpinner(spinnerId) {
		var $spin = $(spinnerId);
		var $offset;
		var $parentObj = $('#modifySearchForm input[type=submit]');
		if ($spin && $spin.css('display')==='none' && $parentObj) {
			$offset = $parentObj.offset();
			$offset.top += (($parentObj.outerHeight()/2)-($spin.height()/2));
				$offset.left -= ($spin.width()+($spin.width()/2));
			$spin.css($offset);
			$spin.show();
			$("body").css("cursor", "wait");
			if ($(".modal-backdrop").length === 0) { // Never go modal twice...
				$("#busyModal").modal({
					keyboard: false,
					backdrop: 'static'
				});
				$(".modal-backdrop").css("opacity", "0");
			} else {
				$spin.css('z-index', 4000); // Higher than UHF...
			}
		}
	}
	
	initialize();
};

var ls = new LocationSearch();/*********************************************************
Search Results - datepicker.js
This is an excerpt from the file found in Trunk at:
..\trunk..\..\hi\src\main\webapp\script\common.js
NOT the 'almost the same version' file found at:
..\trunk..\..\hi\src\main\webapp\script\global.js
/*********************************************************/

jQuery.extend(jQuery.datepicker, {

	/* Erase the input field only. */
	_clearDateNoClose: function(id) {
		var target = jQuery(id);
		var inst = this._getInst(target[0]);
		
		// Clear range styling.
		inst.settings['rangeStart'] = null; 
		inst.settings['rangeEnd'] = null;

		var	dateStr = '';
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			//this._hideDatepicker(); // Don't close the datepicker.
			this._updateDatepicker(inst);
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}		
	}

});

function setupCalendars(checkInDateFieldId, checkOutDateFieldId) {
	
	var commonFooter = '<div class=""><a href="#" class="calendar-reset custControl">'+CALENDAR_DATA.TEXT_RESET_CALENDAR+'</a><div style="margin-top: 10px;"><table width="100%"><tbody><tr><td><div style="background-color: #9ed1ff; float: left; height: 22px; width: 30px;"></div><p style="font-weight: bold; float: left; line-height: 22px; margin-left: 3px;">'+CALENDAR_DATA.AVAILABLE_DATE+'</p></td><td><div style="background-color: #e7e7e7; float: left; height: 22px; width: 30px;"></div><p style="font-weight: bold; float: left; line-height: 22px; margin-left: 3px;">'+CALENDAR_DATA.UNAVAILABLE_DATE+'</p></td><td><div style="float: left; height: 22px; width: 30px;" class="legend-selected-date"></div><p style="font-weight: bold; float: left; line-height: 22px; margin-left: 3px;">'+CALENDAR_DATA.SELECTED_DATE+'</p></td></tr></tbody></table></div></div>';
	
	// Only setup the calendars if their input fields are in the DOM.
	if (jQuery('#' + checkInDateFieldId).length == 0 || jQuery('#' + checkOutDateFieldId).length == 0) {
		return;
	}

	/* iPad functionality for hidding the keyboard input in the modify reservation modules */
	if (navigator.userAgent.match(/iPad/i)) {
		/* Disabling the keyboard for the hotel details calendar */
		jQuery('#' + checkInDateFieldId).attr('readonly', 'readonly');
		jQuery('#' + checkOutDateFieldId).attr('readonly', 'readonly');
	}
	
	var maxDate = new Date(CALENDAR_DATA.TODAY.getTime());
	var tomorrow = new Date(CALENDAR_DATA.TODAY.getTime());
	tomorrow.setDate(tomorrow.getDate() +1);
        maxDate.setDate(maxDate.getDate() + 350);
	var selectedCheckInDate;
	var selectedCheckOutDate;
	jQuery('#' + checkInDateFieldId).datepickerplus({
		numberOfMonths: 2
		,dateFormat: CALENDAR_DATA.JQUERY_DATE_FORMAT
		,highlightRange: true
		,pairedWith: checkOutDateFieldId
		,headerContent: '<div style="padding: 0 0 0.5em" class=""><div style="float: right" class="calendar-close calCloseBtn" title="Select to close.">X</div><div style="float: left; font-weight: bold" class="">' + CALENDAR_DATA.TEXT_SELECT_CHECKIN_DATE + '</div><div style="clear: both"></div></div>'
		,footerContent: commonFooter
		,initialDateRange: 1
		,selectableOnMinDateMinusOne: true
		,onSelect: function(){
		    	try {
			var selectedCheckInDate;
			var selectedCheckOutDate;
                        var $checkOutDate = jQuery('#' + checkOutDateFieldId);

			selectedCheckInDate = jQuery.datepicker.parseDate(CALENDAR_DATA.JQUERY_DATE_FORMAT, jQuery('#' + checkInDateFieldId).val());
			selectedCheckOutDate = jQuery.datepicker.parseDate(CALENDAR_DATA.JQUERY_DATE_FORMAT, jQuery('#' + checkOutDateFieldId).val());

			// Set checkout min date based on checkin date. 
			var minCheckOutDate = new Date(selectedCheckInDate.getTime());
			minCheckOutDate.setDate(minCheckOutDate.getDate() + 1);

			// Set max date to the lesser of (checkin date + 99 days) and maxDate.
			var maxCheckOutDate = new Date(selectedCheckInDate.getTime());
			maxCheckOutDate.setDate(maxCheckOutDate.getDate() + 99);
			if (maxCheckOutDate > maxDate) {
			    maxCheckOutDate = maxDate;
			}

			// Reconfigure checkout date picker.
			$checkOutDate.datepicker('option', 'minDate', minCheckOutDate);
			$checkOutDate.datepicker('option', 'maxDate', maxCheckOutDate);
			$checkOutDate.datepicker('setDate', selectedCheckOutDate);
		    } catch (e) {
			// An exception will be thrown if a date can't be parsed for the checkin or checkout input fields.
			// This happens when the field is blank or has the default "Check In" or "Check Out" value.
		    } 
		}
		,onClose: function (){
		    var $checkOutDate = jQuery('#' + checkOutDateFieldId);
                    var $checkInDate = jQuery('#'+ checkInDateFieldId);
                    if( $checkInDate.datepicker('getDate')== null) {
                        $checkOutDate.datepicker('option', 'maxDate', maxDate);
			$checkOutDate.datepicker('option','minDate', tomorrow);
		    }
		}
	});

	jQuery('#' + checkOutDateFieldId).datepickerplus({
		numberOfMonths: 2
		,dateFormat: CALENDAR_DATA.JQUERY_DATE_FORMAT
		,highlightRange: true
		,pairedWith: checkInDateFieldId
		,headerContent: '<div style="padding: 0 0 0.5em" class=""><div style="float: right" class="calendar-close calCloseBtn" title="Select to close.">X</div><div style="float: left; font-weight: bold" class="">'+CALENDAR_DATA.TEXT_SELECT_CHECKOUT_DATE+'</div><div style="clear: both"></div></div>'
		,footerContent: commonFooter
		,onClose: function(){
		        var $checkOutDate = jQuery('#' + checkOutDateFieldId);

		    	try {
			selectedCheckInDate = jQuery.datepicker.parseDate(CALENDAR_DATA.JQUERY_DATE_FORMAT, jQuery('#' + checkInDateFieldId).val());
			selectedCheckOutDate = jQuery.datepicker.parseDate(CALENDAR_DATA.JQUERY_DATE_FORMAT, jQuery('#' + checkOutDateFieldId).val());

			// Set checkout min date based on checkin date. 
			var minCheckOutDate = new Date(selectedCheckInDate.getTime());
			minCheckOutDate.setDate(minCheckOutDate.getDate() + 1);

			// Set max date to the lesser of (checkin date + 99 days) and maxDate.
			var maxCheckOutDate = new Date(selectedCheckInDate.getTime());
			maxCheckOutDate.setDate(maxCheckOutDate.getDate() + 99);
			if (maxCheckOutDate > maxDate) {
			    maxCheckOutDate = maxDate;
			}

			// Reconfigure checkout date picker.
			$checkOutDate.datepicker('option', 'minDate', minCheckOutDate);
			$checkOutDate.datepicker('option', 'maxDate', maxCheckOutDate);
			$checkOutDate.datepicker('setDate', selectedCheckOutDate);
		    } catch (e) {
			// An exception will be thrown if a date can't be parsed for the checkin or checkout input fields.
			// This happens when the field is blank or has the default "Check In" or "Check Out" value.
		    } 
		}
	});
	
	return {
	    "clearSelectedDates": function() {
			selectedCheckInDate = null;
			selectedCheckOutDate = null;
	    }
	}
}

/* end of datepicker.js */
// this function calls the public google geocode api - does not use the maps js on purpose!  Do not load the maps API simply to geocode!
// var test = google_geocode.lookup('abcde');
//
var Google_Geocode = function() {

	// returns compressed output name/lat/lng as array and status
	this.lookup = function(location) {
		
		var lookup_result = {
			status : 'FAILURE',
			locations : []
		};
		
		$.ajax({
				url : '//maps.googleapis.com/maps/api/geocode/json?sensor=false&address='
						+ encodeURIComponent(location),

				success : function(result) {

					lookup_result.status = result.status;

					for ( var i in result.results) {

						var item = result.results[i];

						var name = item.formatted_address;
						name = name.replace(/\(/g, '');
						name = name.replace(/\)/g, '');
						
						// fourth decimal is equivalent to land parcel differentiation - fifth allows for locating objects as small as trees
						lookup_result.locations.push({
							"name" : encodeURIComponent(name),
							"lat" : precise_round(item.geometry.location.lat, 4),
							"lng" : precise_round(item.geometry.location.lng, 4)
						});
						
						if( i >= 5 ) {
							break;
						}
					}
				},

				async : false
			});
		return lookup_result;
	};
	
	function precise_round(num,decimals){
		return Math.round(num*Math.pow(10,decimals))/Math.pow(10,decimals);
	}
};
var google_geocode = new Google_Geocode();


/****************************************************************
* Google Maps Wrapper - google-maps.js
*****************************************************************/

var GoogleMaps = (function ($) { // See also GLOBAL_GOOGLE_MAPS alias below...

	"use strict"; // (ES5 - jshint.com :)
	/*jshint forin:true, noarg:true, noempty:true, eqeqeq:true, bitwise:true, strict:true,
	undef:true, unused:true, curly:true, browser:true, jquery:true, indent:4, maxerr:50 */
	/*exported GLOBAL_GOOGLE_MAPS*/
	/*global google, MarkerClusterer*/

	var _private = { // Private Closure, changeable only via _public at runtime...

		// data...
		mapMarkerCenterData: {},
		mapMarkerData: [],
		prevMarkers: [],
		mapObj:{},

		// dev testing...
		debug: true // Set to 'false' to suppress TRACE messages in console...
	};

	var _public  = { // Shared access, changeable at runtime...

		// entry points...
		onDocumentReady: {},

		// modules...
		initGoogleMaps: {}, // Google Maps callback...
		loadMapMarkerData: {},
		createInstance: {},

		// Read-only helper functions...
		getPrevMarkers: function () {
			return _private.prevMarkers;
		},
		
		getMap: function () {
			return _private.mapObj;
		},

		// Console Debug Output.
		// Usage: GoogleMaps.TRACE('msg') === console.log('msg')
		TRACE: (_private.debug && window.console && window.console.log && window.console.log.bind) ? window.console.log.bind(window.console) : function () {}
	};

	// Main processing AFTER document is loaded and the DOM is ready.
	// Note: This is the same exact thing as $(document).ready(function() {}
	// Please refrain from adding any 'other' document.ready() calls.
	_public.onDocumentReady = $(function () {

		// Delayed / Async load of Google Maps API.
		loadGoogleMapsAPI();
	});

	_public.initGoogleMaps = function () {

		// Perform any init here - Google Map API is loaded and ready...
	};

	// Load all shared map markers.
	_public.loadMapMarkerData =	function (jsonCenterData, jsonMapData) {
		GoogleMaps.TRACE('INFO: Setting Map Marker Data...');
		_private.mapMarkerCenterData = jsonCenterData;
		_private.mapMarkerData = jsonMapData;
	};

	_public.createInstance = function (container, lat, long, options, mnemonic, viewtype) {
		GoogleMaps.TRACE('INFO: Loading map for ' + mnemonic + ' in ' + viewtype);
		var target = (container instanceof jQuery ? container[0] : container);
		if (!target) {
			GoogleMaps.TRACE('ERROR: Map container div not found!');
			return; // Bail if map div not found...
		}
		var map = new google.maps.Map(target, options);
		_private.mapObj = map;
		applyMapMarkerData(map, mnemonic, viewtype);
		if (viewtype === "listview") {
			var coords = new google.maps.LatLng(lat, long);
			map.setCenter(coords);
		} else { /* "mapview" */
			var bounds = new google.maps.LatLngBounds();
			$.each(_private.mapMarkerData, function(index, value) {
				bounds.extend(new google.maps.LatLng(value.latitude, value.longitude));
			});
			map.setCenter(bounds.getCenter());
			map.fitBounds(bounds);
			google.maps.event.addListenerOnce(map, 'bounds_changed', function() {
				if (this.getZoom() > 16){
					this.setZoom(16); // Max initial zoom level...
				}
			});
		}

		applyMapRouteData(map);

		// This is the fix for the GMap 'repaint' bug in v.3 maps...
		setTimeout(function() {
			google.maps.event.trigger(map, 'resize');
		}, 100);

		return map;
	};

	// Delayed / Async load of Google Maps API.
	function loadGoogleMapsAPI() {
		// Hide GOOGLE MAP FUNCTIONALITY for China
		if(akamaiCountryCode.toLowerCase() != "cn"){
			GoogleMaps.TRACE('INFO: Loading GMap API...');
			if (typeof google !== "undefined" && typeof google.maps !== "undefined") {
				return google.maps;
			}
			var script = document.createElement('script');
			script.type = 'text/javascript';
			script.src = '//maps.googleapis.com/maps/api/js?client=gme-sixch&sensor=false&' +
				'language=' + SERVER_VARIABLES.mapLang + '&' +
				'callback=GoogleMaps.initGoogleMaps';
			document.body.appendChild(script);
		}
	}

	// Apply map markers for supplied map...
	function applyMapMarkerData(map, selectedHotel, viewtype) {
		GoogleMaps.TRACE('INFO: Applying Map Markers...');
		var markers = [];
		var infoWindows = [];
		var contentString, brandCode, geoLat, geoLong, hotelName, mnemonic, available;
		
		// Only apply the center when its not along the route search
		if (typeof ROUTE_DETAILS === 'undefined'){
		// apply the center
		GoogleMaps.TRACE('INFO: City Center: ' + _private.mapMarkerCenterData.latitude + ", " + _private.mapMarkerCenterData.longitude);
		var marker = new google.maps.Marker({
	        position: new google.maps.LatLng(_private.mapMarkerCenterData.latitude, _private.mapMarkerCenterData.longitude),
	        map: map,
	        icon: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'
	      });
		 markers.push(marker);
		}

		// apply the marker
		$.each(_private.mapMarkerData, function(index, value) {

				brandCode = value.brandCode;
				geoLat = value.latitude;
				geoLong = value.longitude;
				hotelName = value.displayName;
				mnemonic = value.hotelCode;
				available = true; // MapView needs to provide this value?...
				contentString = "Loading...";
			
			var infoWindow = new google.maps.InfoWindow({
				content: contentString
			});
			infoWindows.push(infoWindow);

			var coords = new google.maps.LatLng(geoLat, geoLong);
			var marker = new google.maps.Marker({
				position : coords,
				map : map,
				title: hotelName,
				mnemonic: mnemonic
			});
			markers.push(marker);
			_private.prevMarkers = markers; // Store ref to last created marker set for Selenium testing...


			// Custom Map Markers per Brand...
			if (selectedHotel === mnemonic) {
				marker.setIcon(SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_' + brandCode + '_map_pin.png'); 
			} else {
				if (available) {
					marker.setIcon(SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_' + brandCode + '_map_pin.png'); 
				} else {
					marker.setIcon(SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_' + brandCode + '_map_pin.png'); 
				}
			}

			// Bind click event to marker.
			google.maps.event.addListener(infoWindow, 'domready', function() {
				var mySpan = $('.starRatingsMnemonic-'+marker.mnemonic);
				if(mySpan.text() != '0.0') {
					mySpan.stars();					
				}
				
				GLOBAL_SEARCH_RESULTS_PAGE.bindMapBulkCalendarLinks();
			});

			// Bind click event to marker.
			google.maps.event.addListener(marker, 'click', function() {
					$.ajax(value.ajaxUrl, {
						timeout: 60000,
						success: function(data) {
							infoWindow.setContent(data);
						},
						error: function() {
							infoWindow.setContent("Failed to load map marker data.");
						},
						complete: function() {
							closeAllMarkerPopups(infoWindows);
							infoWindow.open(map, marker);
							map.setCenter(marker.getPosition());
							map.panBy(0,-200);
							IHGflexslider.initFlexSliderImgErrorHandler('img-polaroid img-polaroidplaceholdermapview','photoViewerWrapper');
						}
					});
			});

			// Auto open selected marker popup...
			if (selectedHotel === mnemonic) {
				
				$.ajax(value.ajaxUrl, {
					timeout: 60000,
					success: function(data) {
						infoWindow.setContent(data);
					},
					error: function() {
						infoWindow.setContent("Failed to load map marker data.");
					},
					complete: function() {
						closeAllMarkerPopups(infoWindows);
						var bounds= new google.maps.LatLngBounds();
						bounds.extend(marker.getPosition());
						map.fitBounds(bounds);
						map.setZoom(17);
						infoWindow.open(map,marker);
						map.setCenter(marker.getPosition());
						map.panBy(0,-200);
						IHGflexslider.initFlexSliderImgErrorHandler('img-polaroid img-polaroidplaceholdermapview','photoViewerWrapper');
					}
				});
			}
		});	

		// Set style options for marker clusters.
		var clusterStyles = [
			{
				anchorText: [30, 0],
				textColor: '#CCC',
				url: SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_xx_map_pin.png',
				height: 42,
				width: 50
			},
			{
				anchorText: [30, 0],
				textColor: '#CCC',
				url: SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_xx_map_pin.png',
				height: 42,
				width: 50
			},
			{
				anchorText: [30, 0],
				textColor: '#CCC',
				url: SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_xx_map_pin.png',
				height: 42,
				width: 50
			},
			{
				anchorText: [30, 0],
				textColor: '#CCC',
				url: SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_xx_map_pin.png',
				height: 42,
				width: 50
			},
			{
				anchorText: [30, 0],
				textColor: '#CCC',
				url: SERVER_VARIABLES.resourcesRoot + '/images/map_markers/img_xx_map_pin.png',
				height: 42,
				width: 50
			}
		];

		var clusterOptions = {
			gridSize: 50,
			styles: clusterStyles,
			maxZoom: 15,
			clusterClass: 'marker_cluster'
		};
		
		// Create cluster controller...
		var markerCluster = new MarkerClusterer(map, markers, clusterOptions);
		
	}

	// Apply route for supplied map...
	function applyMapRouteData(map){
		
		if (typeof ROUTE_DETAILS !== 'undefined'){
		
			// Add route to the map for along the route search
			GoogleMaps.TRACE('INFO: Applying route on the map...');
			// GoogleMaps.TRACE('Route details: ', ROUTE_DETAILS);
			
			var directionsDisplay = new google.maps.DirectionsRenderer();
			var directionsService = new google.maps.DirectionsService();
			
			var startPoint = new google.maps.LatLng(ROUTE_DETAILS.startLat, ROUTE_DETAILS.startLong);
			var endPoint = new google.maps.LatLng(ROUTE_DETAILS.endLat, ROUTE_DETAILS.endLong);
			
			var mapOptions = {
					zoom: 7,
					center: startPoint
				};
			
			directionsDisplay.setMap(map);
			
			var request = {
					origin:startPoint,
					destination:endPoint,
					travelMode: google.maps.TravelMode.DRIVING
				};
			
			directionsService.route(request, function(result, status) {
				if (status === google.maps.DirectionsStatus.OK) {
					directionsDisplay.setDirections(result);
				}	
			});
		}
	}

	// Map marker popup dialogs - single instance helper
	function closeAllMarkerPopups(popups) {
		for (var i=0; i<popups.length; i++) {
			popups[i].close();
		}
	}

	// Return public methods.
	return _public;

}(window.jQuery));

// Alias as GLOBAL_*_* to protect namespace...
var GLOBAL_GOOGLE_MAPS = GoogleMaps;

/* end of google-maps.js */
/****************************************************************
* Hotel Search Results - search.js
*****************************************************************/

var SearchResultsPage = (function ($) { // See also GLOBAL_SEARCH_RESULTS_PAGE alias below...

	"use strict"; // (ES5 - jshint.com :)
	/*jshint forin:true, noarg:true, noempty:true, eqeqeq:true, bitwise:true, strict:true,
	undef:true, unused:true, curly:true, browser:true, jquery:true, indent:4, maxerr:50 */
	/*exported GLOBAL_SEARCH_RESULTS_PAGE */
	/*global RES_DIRECT_DATA, setupCalendars, google_geocode*/

	var _private = { // Private Closure, changeable only via _public at runtime...

		// private vars (private vars cannot access public vars inside self...)
		version: "1.0.2",

		// private functions
		setVersion: function (num) {
			_private.version = num;
		},

		// dev testing...
		debug: true // Set to 'false' to suppress TRACE messages in console...
	};

	var _public  = { // Shared access, changeable at runtime...

		// entry points...
		onStartUp: {},
		onDocumentReady: {},

		// modules...

		// public vars
		copyright: "Copyright \u00A92014 IHG\u00AE - InterContinental Hotels Group, PLC",

		// Read-only version number.
		getVersion: function () {
			return _private.version;
		},

		// Console Debug Output.
		// Usage: SearchResultsPage.TRACE('msg') === console.log('msg')
		TRACE: (_private.debug && window.console && window.console.log && window.console.log.bind) ? window.console.log.bind(window.console) : function () {}
	};

	// Main init IIFE for doing anything that needs to be done BEFORE the document is ready.
	// Note: Any code in this module will 'slow down' page rendering...
	// Please keep this as small as possible and do not reference any DOM objects in here!
	_public.onStartUp = (function () {
		return;
	}());

	// Main processing AFTER document is loaded and the DOM is ready.
	// Note: This is the same exact thing as $(document).ready(function() {}
	// Please refrain from adding any 'other' document.ready() calls.
	_public.onDocumentReady = $(function () {

		// Bind tab control events.
		bindTabControlActions();

		// Bind all custom select dropdowns.
		bindCustomSelectDropdowns();

		// Bind all custom select dropdowns for PAL.
		bindCustomSelectDropdownsPAL();

		// Bind Rate Preferences multi-select dropdown.
		bindRatePreferences();

		// Bind Calendar for Check-In and Check-Out dates.
		bindCalendarControl();

		// Show/Hide Modify Search Options.
		bindModifySearchToggle();

		// Show/Hide Destination Options.
		bindDestinationToggle();

		// Show/Hide Along a Route Options.
		bindAlongRouteToggle();

		// Show/Hide Corp ID Options.
		bindCorpToggle();

		// Show/Hide IATA# Options.
		bindIATAToggle();

		// Show/Hide Group Code Options.
		bindGroupToggle();

		// Bind Sort Options toolbar.
		bindSortOptionsToolBar();

		// Bind currency converter and user's currency preference
		bindCurrencyConverter();

		// Bind Star Ratings.
		bindStarRatingsControlbar();

		// Bind Res Direct Numbers.
		bindResDirectNumbers();

		// Check for empty result set - no rows returned...
		bindEmptyResultSet();

		// Bind Show More button.
		bindShowMoreRows();

		// Special Form POST fixups...
		bindFormPost();

		// Trigger the clarify extension - if found
		triggerClarifyExt();
		
		// Bind bulk avail 'close' event.
		bindBulkAvailClose();
		
		// Bind bulk avail 'link' events.
		bindBulkAvailLinks();

		// Bind the Select Dates button.
		bindSelectDatesBtn();

		// Bind the Change Dates buttons.
		bindChangeDatesBtns();

		// Bind the Bonus Points links.
		bindBonusPointsHref();

		// Bind the Bonus Points description.
		bindBonusPointsDesc();

		// Bind the Bonus Points description.
		bindIE_Fixups();
		
		bindRoomkey();
		
        // Initialize Img Error Handler For Flex Slider
        IHGflexslider.initFlexSliderImgErrorHandler('img-polaroid noRoomPhotos','photoViewerWrapper');
		
	});

	// Bind tab control events.
	function bindTabControlActions() {
		$('.nav-tabs a').on('click', function (/*e*/) {
			// Tabs now force page reload - so nothing to do here anymore...
		});
	}

	// Bind currency converte and user's preference
	function bindCurrencyConverter() {
		$('.cc_selection').multiselect({
			buttonClass: 'btn btn-sm spanB1',
			buttonWidth: false,
			buttonContainer: '<div class="btn-group spanB1" />',
			selectedClass: 'active',
			maxHeight: 370
		});

		var selectedCurrency = $.cookie("cc_currencySelected");
		if (selectedCurrency) {
			$(".currencySelection .multiselect.cc_selection").multiselect('select', selectedCurrency);
			invokeCC();
		}
	}

	// Bind all custom select dropdowns.
	function bindCustomSelectDropdowns() {
		$('#adultCount, #childCount, #roomCount').multiselect({
			buttonClass: 'btn btn-sm spanS1',
			buttonContainer: '<div class="btn-group spanS1" />',
			selectedClass: 'active',
			maxHeight: false
		});
	}

	// Bind all custom select dropdowns for PAL.
	function bindCustomSelectDropdownsPAL() {
		$('#ctlDestPAL').multiselect({
			buttonClass: 'btn btn-sm',
			buttonWidth: '310px',
			buttonContainer: '<div class="btn-group spanC1" />',
			selectedClass: 'active',
			maxHeight: 370
		});

		$('#ctlTravelType').multiselect({
			buttonClass: 'btn btn-sm',
			buttonWidth: '122px',
			buttonContainer: '<div class="btn-group spanC2" />',
			selectedClass: 'active',
			maxHeight: 370
		});

		$('#ctlDVQType').multiselect({
			buttonClass: 'btn btn-sm',
			buttonWidth: '310px',
			buttonContainer: '<div class="btn-group spanC3" />',
			selectedClass: 'active',
			maxHeight: 370
		});

		// Fixup cotrol row offset due to hidden select/no-js support.
		$('.btn-group.spanC1:nth-child(2)').addClass('firstOffset');

		// Offical Travel Options...
		$('input[name="selectedTravelType"]').on('change',function () {
			if($(this).val()==='official') {
				$('.btn-group.spanC2').show('slow');
				$('#ctlTravelType').change();
			} else {
				$('.btn-group.spanC2').hide('slow');
				$('.btn-group.spanC3').hide('slow');
			}
		});

		// DVQ Travel Options...
		$('#ctlTravelType').on('change',function () {
			if($(this).val()==='DVQ') {
				$('.btn-group.spanC3').show('slow');
			} else {
				$('.btn-group.spanC3').hide('slow');
			}
		});

		// PAL Init controls after page reload...
		if ($('#officialOption2').prop('checked')) {
			$('.btn-group.spanC2').show('slow');
			$('#ctlTravelType').change();
		} else {
			$('.btn-group.spanC2').hide('slow');
			$('.btn-group.spanC3').hide('slow');
		}
		if ($('#ctlGroupCode').length>0 && $('#ctlGroupCode').val().length>0) {			
			$('#ctlGroupCode, #ctlGroupCodeHelp').show('slow');
		}else{
			$('#ctlGroupCode, #ctlGroupCodeHelp').hide('slow');
		}
	}

	// Bind Rate Preferences multi-select dropdown.
	function bindRatePreferences() {
		$('#selectedRateCodes').multiselect({
			buttonClass: 'btn btn-sm',
			buttonWidth: '175px',
			buttonContainer: '<div class="btn-group spanM1" />',
			selectedClass: 'active',
			maxHeight: false,
            selectAllValue: '6CBARC',
            selectAllSpecial: false,
			buttonText: function (options, select) {
				if (options.length===0) {
					return $(select).find("option:first").text() + ' <b class="caret"></b>';
				} else if (options.length > 1) {
					return '(' + options.length +') ' + select.attr('data-count') + ' <b class="caret"></b>';
				} else {
					var selected='';

					options.each(function () {
						selected+=$(this).text()+', ';
					});

					return selected.substr(0, Math.min(selected.length-2,22))+' <b class="caret"></b>';
				}
			}
		});
	}

	// Bind Sort Options toolbar.
	function bindSortOptionsToolBar() {
		$('#ratingsFilter, #smokingFilter, #distanceFilter').multiselect({
			buttonClass: 'btn btn-sm spanB1',
			buttonWidth: false,
			buttonContainer: '<div class="btn-group spanB1" />',
			selectedClass: 'active',
			maxHeight: 370
		});

		//Adjust Currency dropdown max-height if there is only one result found to avoid elements overlapping
		var currencyDropdownMaxHeight = 370;
		if ($('#searchResultContainer').children('div').size() == 1) {
			currencyDropdownMaxHeight = 260;
		}
		$('.cc_selection').multiselect({
			buttonClass: 'btn btn-sm spanB1',
			buttonWidth: false,
			buttonContainer: '<div class="btn-group spanB1" />',
			selectedClass: 'active',
			maxHeight: currencyDropdownMaxHeight
		});

		// Sort By dropdown...
		$('#sortByOption').multiselect({
			buttonClass: 'btn btn-sm spanB1 sortByButton',
			buttonWidth: false,
			buttonContainer: '<div class="btn-group spanB1 sortByDiv" />',
			selectedClass: 'active',
			maxHeight: 370,
			onChange: function(element /*, checked*/) {
				showBusySpinner('#busySpinner', element.parent().next().find('button'), 'right');
				element.closest('form').trigger('submit');
			}
		});

		// Special behavior for 'Amenities' dropdown...
		$('#amenitiesFilter').multiselect({
			buttonClass: 'btn btn-sm spanB1',
			buttonWidth: false,
			buttonContainer: '<div class="btn-group spanB1" />',
			selectedClass: 'active',
			maxHeight: 370,
			selectAllValue: 'all_amenities',
			selectAllInverse: true,
			buttonText: function (options, select) {
				if (options.length===0) {
					return select.attr('data-all') + ' <b class="caret"></b>';
				}
				else if (options.length > 1) {
					return '(' + options.length +') ' + select.attr('data-count') + ' <b class="caret"></b>';
				}
				else {
					var selected='';
					options.each(function () {
						selected+=$(this).text()+', ';
					});
					var maxChars;
					switch (SERVER_VARIABLES.currLangCode) {
						case 'ar':
						case 'iw':
							maxChars = 40;
							break;
						default:
							maxChars = 27;
							break;
					}
					return selected.substr(0, Math.min(selected.length-2,maxChars))+' <b class="caret"></b>';
				}
			}
		});

		// Special behavior for 'Brands' dropdown...
		$('#brandsFilter').multiselect({
			buttonClass: 'btn btn-sm spanB1',
			buttonWidth: false,
			buttonContainer: '<div class="btn-group spanB1" />',
			selectedClass: 'active',
			maxHeight: 370,
			selectAllValue: 'all_brands',
			selectAllSpecial: true,
			currentBrandCode: $('#brandsFilter').attr('data-brand'),
			buttonText: function (options, select) {
				if (options.length===0 || (options.length === $('option[value!="' + this.selectAllValue + '"]', select).length)) {
					return select.attr('data-all') + ' <b class="caret"></b>';
				}
				else if (options.length > 1) {
					return '(' + options.length +') ' + select.attr('data-count') + ' <b class="caret"></b>';
				}
				else {
					var selected='';
					options.each(function () {
						selected+=$(this).text()+', ';
					});
					return selected.substr(0, selected.length-2)+' <b class="caret"></b>';
				}
			}
		});

		// 'Filter By' dropdown...
		$('#miscFilter').multiselect({
			buttonClass: 'btn btn-sm spanB1',
			buttonWidth: false,
			buttonContainer: '<div class="btn-group spanB1" />',
			selectedClass: 'active',
			maxHeight: 370,
			selectAllValue: 'all_misc_filters',
			onChange: function(element, checked) {
				var elemValue = element.val();

				if (elemValue === "NSMR" && checked === true) {
					// Deselect Smoking
					$('#miscFilter').multiselect('deselect',"SMR");
				} else if (elemValue === "SMR" && checked === true) {
					// Deselect Non-smoking
					$('#miscFilter').multiselect('deselect',"NSMR");
				}
			},
			buttonText: function (options, select) {
				if (options.length === 0) {
					return select.attr('data-all') + ' <b class="caret"></b>';
				}
				else if (options.length > 1) {
					return select.attr('data-count').replace('{0}', options.length) + ' <b class="caret"></b>';
				}
				else {
					var selected='';
					options.each(function () {
						selected+=$(this).text()+', ';
					});
					var maxChars;
					switch (SERVER_VARIABLES.currLangCode) {
						case 'ar':
						case 'iw':
							maxChars = 40;
							break;
						default:
							maxChars = 27;
							break;
					}
					return selected.substr(0, Math.min(selected.length-2,maxChars))+' <b class="caret"></b>';
				}
			}
		});

		// Fixup control row offset due to hidden select/no-js support.
		$('.btn-group.spanB1:nth-child(2)').addClass('firstOffset');
	}

	// Bind Star Ratings.
	function bindStarRatingsControlbar() {
		$('span.starRatings').stars();
	}

	// Bind Res Direct Numbers.
	function bindResDirectNumbers() {
		var phoneNums;
		$.ajax({ 
			type: 'GET', 
			url: RES_DIRECT_DATA.RES_DIRECT_NUMBER_AJAX_URL,
			dataType: 'json'
		})
		.done(function(data /*, textStatus, jqXHR*/) {
			phoneNums = data;
		})
		.fail(function(/* jqXHR, textStatus, errorThrown*/) {
			// Note: This should default to all global numbers per brand/country/lang...
			phoneNums =
			{
				"resDirectNumberBulk":{
					"global": {
						"number": "1-877-424-2449",
						"message": ""
					}
				}
			};
		})
		.always(function(/*data, textStatus*/) {
			$('.resRow .selectedHotelCode').each(function(i, dt) {
				var tg = $(this).parent().find('.resDirect');
				var ds = phoneNums.resDirectNumberBulk[dt.value];
				if (tg) {
					if (ds) {
						tg.text(ds.number);
						if (ds.message) {
							tg.next().html('(' + ds.message + ')<br>');
						}
					} else {
						tg.text(phoneNums.resDirectNumberBulk.global.number);
					}
				}
			});
			var globalNumber = phoneNums.resDirectNumberBulk.global.number;
			$('.globalResDirectNumber').each(function() { 
				$(this).text(	globalNumber );
			});
		});
	}

	// Show/Hide Modify Search Options.
	function bindModifySearchToggle() {
		$('#toggleModifySearch, .toggleModifySearch').click(function(e) {
			e.preventDefault();
			$('#searchOptions, #modifySearch').slideToggle('slow');
		});
	}

	// Show/Hide Along the Route Options.
	function bindAlongRouteToggle() {
		$('#toggleAlongRoute').click(function(e) {
			e.preventDefault();
			
			$('#lblDest, #lblStart, #ctlDest, #ctlDestHelp, #ctlStart, #ctlStartHelp, #ctlEndHelp, .endRoute, #toggleAlongRoute, #toggleByDestination').toggleClass('hide');
			$('#mapView').val("true");
			SERVER_VARIABLES.isAlongRoute = true;

			// clear & copy destination 
			$('#ctlEnd').val($('#ctlDest').val());
			$('#ctlDest').val('');
		});
	}

	// Show/Hide Destination Options.
	function bindDestinationToggle() {
		$('#toggleByDestination').click(function(e) {
			e.preventDefault();
			
			$('#lblDest, #lblStart, #ctlDest, #ctlDestHelp, #ctlStart, #ctlStartHelp, #ctlEndHelp, .endRoute, #toggleAlongRoute, #toggleByDestination').toggleClass('hide');
			$('#mapView').val("false");
			SERVER_VARIABLES.isAlongRoute = false;

			// clear & copy route
			$('#ctlDest').val($('#ctlEnd').val());
			$('#ctlStart').val('');
			$('#ctlEnd').val('');
		});
	}

	// Show/Hide Corp ID Options.
	function bindCorpToggle() {
		$('#toggleCorpID').click(function(e) {
			e.preventDefault();
			$('#ctlCorpID, #ctlCorpIDHelp').toggle('slow');
		});
	}

	// Show/Hide IATA# Options.
	function bindIATAToggle() {
		$('#toggleIATA').click(function(e) {
			e.preventDefault();
			$('#ctlIATA, #ctlIATAHelp').toggle('slow');
		});
	}

	// Show/Hide Group Code Options.
	function bindGroupToggle() {
		$('#toggleGroupCode').click(function(e) {
			e.preventDefault();
			$('#ctlGroupCode, #ctlGroupCodeHelp').toggle('slow');
		});
	}
		
	// Bind Calendar for Check-In and Check-Out dates.
	function bindCalendarControl() {
		try { // None of the calendar js is trustable. :(

			// Setup datepicker calendars for Change Search.
			setupCalendars('checkInDate', 'checkOutDate');

			// Setup datepicker calendars for Select Dates dialogs.
			setupCalendars('checkInDatePopup', 'checkOutDatePopup');

			$('.inlineCalControl').click(function(e) {
				e.preventDefault();
				var targetField = $(this).attr('name');
				$(targetField).focus();
				return false;
			});
		}
		catch(err) {}
	}

	// Check for empty result set - no rows returned...
	function bindEmptyResultSet() {
		if ($('.noRowsReturned').length > 0) {
			$('#toggleModifySearch').trigger("click");
		}
	}

	// Bind Show More button.
	function bindShowMoreRows() {
		$('#searchResultContainer').on('click', '#showMoreLink', function(e) {
			e.preventDefault();
			
			showBusySpinner('#busySpinner', $('#showMoreLink'), 'left');
			$.ajax({
				type: 'GET', 
				url: $(this).attr('href')+'&ajax=true',
				dataType: 'html'
			})
			.always(function(data, textStatus) {
				if (textStatus === 'success' && data.indexOf('results_row_') !== -1) {
					$('#searchResultContainer').html(data);
					bindStarRatingsControlbar();
                    bindBulkAvailLinks();
					// Re-execute Currency Converter
					if($('.cc_selection').val() !== "X"){ // Prevent call if there is no currency selected
						setTimeout(function(){
							invokeCC();
						},5);
					}
				}
				hideBusySpinner('#busySpinner');
				IHGflexslider.initFlexSliderImgErrorHandler('img-polaroid noRoomPhotos','photoViewerWrapper');
			});
		});

		$('#searchResultContainer').on('click', '#showAllLink', function(e) {
			e.preventDefault();
			
			// close any details up
			$("div[id^=vhd]").find(":visible").each(function(){
				$(this).css('display', 'none');
			});

			showBusySpinner('#busySpinner', $('#showAllLink'), 'hardRight');
			$.ajax({
				type: 'GET',
				url: $(this).attr('href')+'&ajax=true',
				dataType: 'html'
			})
			.always(function(data, textStatus) {
				if (textStatus === 'success' && data.indexOf('results_row_') !== -1) {
					$('#searchResultContainer').html(data);
					bindStarRatingsControlbar();
                    bindBulkAvailLinks();
					
					// Re-execute Currency Converter
					if($('.cc_selection').val() !== "X"){ // Prevent call if there is no currency selected
						setTimeout(function(){
							invokeCC();
						},5);
					}
				}
				hideBusySpinner('#busySpinner');
				IHGflexslider.initFlexSliderImgErrorHandler('img-polaroid noRoomPhotos','photoViewerWrapper');
			});
		});
	}

	// Special Form POST fixups...
	function bindFormPost() {

		// Forms that are posted...
		$('#modifySearchForm, #filterSortForm').bind('submit', function() {

			// Show the busy spinner.
			showBusySpinner('#busySpinner', $(this).find('input[type=submit]'), 'left');

			// Re-enable 'Best Available' selection so it will get posted...
			$(this).find('option[value="6CBARC"]').prop("disabled", false);

			// Disable 'All Brands' selection so it will NOT get posted...
			$(this).find('option[value="all_brands"]').prop("disabled", true);
		});

		// Links to other pages...
		$('#searchResultContainer, #mapViewContainer').on('click', '.bookAnchor input', function(/*e*/) {
			// Show the busy spinner.
			showBusySpinner('#busySpinner', $(this), 'left');

			// Fixup for IE7/8.
			var ieVersion = getIE_version();
			if (ieVersion === 7 || ieVersion === 8) {
				window.location.href = $(this).parent().attr('href');
			}
		});

		// Nav Tabs for listTab and  mapTab...
		$(".nav li.active a, .nav li.next a").click(function(){
			showBusySpinner('#busySpinner', $(this), 'forceRight');
		});
	}

	// Show the shared busy spinner.
	function showBusySpinner(spinnerId, $parentObj, sideToPos) {
		var $spin = $(spinnerId);
		var $isRTL;
		var $offset;
		var $header = $('body').find('header');
		var $stickyUHF = $('body').find('.UHF_sticky');

		if ($spin && $spin.css('display')==='none' && $parentObj) {
			$isRTL = $parentObj.css('direction') === 'rtl';
			$offset = $parentObj.offset();
			$offset.top += (($parentObj.outerHeight()/2)-($spin.height()/2));
			//As per the new UHF header, we need to subtract the height of header.
			if(typeof $header !== 'undefined'){
				if ($stickyUHF.is(":visible") === true) {
					$offset.top = $offset.top - $header.height()
							- $stickyUHF.height();
				} else {
				$offset.top = $offset.top - $header.height();
			}
			}
			if (sideToPos === 'left') {
				if ($isRTL) {
					$offset.left += ($parentObj.outerWidth()+($spin.width()/2));
				} else {
					$offset.left -= ($spin.width()+($spin.width()/2));
				}
			}
			else if (sideToPos === 'hardRight') {
				if ($isRTL) {
					$offset.left -= 30;
				} else {
					$offset.left += $parentObj.outerWidth()+10;
				}
			}
			else if (sideToPos === 'forceRight') {
				if ($isRTL) {
					$offset.left += 10;
				} else {
					$offset.left += $parentObj.width()+48;
				}
			}
			else { // 'right'
				if ($isRTL) {
					$offset.left -= ($spin.width()+($spin.width()/2));
				} else {
					$offset.left += ($parentObj.outerWidth()+($spin.width()/2));
				}
			}
			$spin.css($offset);
			$spin.show();
			$("body").css("cursor", "wait");
			if ($(".modal-backdrop").length === 0) { // Never go modal twice...
				$("#busyModal").modal({
					keyboard: false,
					backdrop: 'static'
				});
				$(".modal-backdrop").css("opacity", "0");
			} else {
				$spin.css('z-index', 4000); // Higher than UHF...
			}
		}
	}

	// Hide the shared busy spinner.
	function hideBusySpinner(spinnerId) {
		$(spinnerId).css({
			'display':'none',
			'position':'absolute',
			'top':'0px',
			'left':'-99999px'
		});
		$("body").css("cursor", "default");
		$("#busyModal").modal("hide");
	}

	// triggers the google clarify if the form is found due to unable to clarify - this trigger is for destination box
	function triggerClarifyExt() {
		try {
			var $theElem = $('.unableToClarify');
			if($theElem.length > 0) {
				// toggle message
				$('#failedToClarify').css('display','none');
				$('#attemptingGoogle').css('display','inline');
				
				var $ctlDest = $('#ctlDest');
				if( $ctlDest ) {
					var result = google_geocode.lookup($ctlDest.val());
					if( result.status === 'OK' ) {
						
						// write cookie
						$.cookie("clarifyDestExtResult", JSON.stringify(result), {path:'/'});

						location.reload();
					} else {
						// toggle message
						$('#attemptingGoogle').css('display','none');					
						$('#failedToClarify').css('display','inline');
					}				
				}
			} else {
				// clear any existing cookie
				$.removeCookie("clarifyDestExtResult", {path:'/'});
			}			
		} catch ( e ) {
			// this is non critical functionality - do not remove the safety this provides.
			// toggle message
			$('#attemptingGoogle').css('display','none');					
			$('#failedToClarify').css('display','inline');
		}
	}

	// Bind bulk avail 'close' event.
	function bindBulkAvailClose() {
		$('body').on('click', '#bulkAvailCalClose', function() {
			$('#bulkAvailContainer').modal('hide');
			$('#bulkAvailContainer').html('');
		});
	}
	
	// Bind bulk avail 'link' events.
	function bindBulkAvailLinks() {
		$('.bulkAvailLink').on('click', function(e) {
			e.preventDefault();
			showBusySpinner('#busySpinner', $(this));
			$.ajax($(this).attr('loadHref'), {
				timeout: 60000,
				success: function(data) {
					$('#bulkAvailContainer').html(data);
					$('#bulkAvailModal').modal('show');
				},
				error: function() {
					$('#bulkAvailError').modal('show');
				},
				complete: function() {
					hideBusySpinner('#busySpinner');
				}
			});
		});
	}

	// Bind the Select Dates button.
	function bindSelectDatesBtn() {
		$('body').on('click', '.selectDatesBtn', function(/*e*/) {
			var anchorValue = $(this).closest('div.resRow').find('.selectedHotelCode').val();
			var anchorInput = $('#modifySearchForm').find('input[name="anchorName"]');
			$(anchorInput).val(anchorValue);	

			popupRoomKey();

		});
	}

	// Bind the Change Dates buttons.
	function bindChangeDatesBtns() {
		$('body').on('click', '#checkAvailButton', function (e) {
			e.preventDefault();
			var isCheckInPresent = validateInput("#checkInDatePopup");
			var isCheckOutPresent =  validateInput("#checkOutDatePopup");
			if(isCheckInPresent && isCheckOutPresent){
				$('#checkInDate').val($('#checkInDatePopup').val());
				$('#checkOutDate').val($('#checkOutDatePopup').val());
				showBusySpinner('#busySpinner', $(this), 'left');

				popupRoomKey();

				$('#modifySearchForm').submit();
			}else{
				$('.close').click(function(){clearPopUpError();});
			}
		});
	}

	function validateInput(id){
		if( !$(id).val() ) {
	        $(id).effect("highlight", {}, 2000);
		    $("#selectDatesErrorMessage").removeClass("hidden");
	        $(id).css("box-shadow", "0 0 4px #FF0000");
		    $("#selectDatesErrorMessage ").css("background", "url(" + $("#backgroundURL").val() + ")"); 
			return false;
	    }
	    return true;
	}
	
	function clearPopUpError(){
	    $("input").css("box-shadow","");
        $("#selectDatesErrorMessage").addClass("hidden");
	}


	// Bind the Bonus Points links.
	function bindBonusPointsHref() {
		$('body').on('click', 'input[name$="_pts"]', function(/*e*/) {
			$(this).closest('div.resRow').find('a.bookAnchor').attr('href', $(this).attr('value'));
		});
	}

	// Bind the Bonus Points description.
	function bindBonusPointsDesc() {
		$('#bonusPointsPopup').on('data-dynamic', function (e, data) {
			$(this).find('h6.data-dynamic').html($(data).attr('data-descTitle'));
			$(this).find('p.data-dynamic').html($(data).attr('data-descBody'));
		});
	}

	// IE Specific JS.
	function bindIE_Fixups() {
		$('.lt-ie9 .multiselect-container a').click(function() {
			var $radio = $(this).find('input:radio');
			$radio.prop("checked", !$radio.prop("checked"));
			$radio.change();
		});
	}

	function popupRoomKey() {
			try {
				if (isChinaOnAkamai() == false) {
					RoomKey.loadPopunder(roomkey_config, false);
				}
			} catch(err) {
			SearchResultsPage.TRACE('ERROR RoomKey: '+err.message);
			}
	}
	
	function isChinaOnAkamai(){
		if (AKAMAI_COUNTRY_CODE.toLowerCase() == 'cn'){
			return true;
		}
		return false;
	}
	
	function bindRoomkey() {
		//From hotel search results page
		$("#btnChangeSearch, #btnApplyFilter, .checkRates").click(function(){
			popupRoomKey();
			return true;
		});
	}
	
	// IE 8/11+ version checking.
	function getIE_version() {
		var rv = -1;
		try {
			if (navigator.appName === 'Microsoft Internet Explorer') {
				var ua = navigator.userAgent;
				var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
				if (re.exec(ua) !== null) {
					rv = parseFloat(RegExp.$1);
				}
			}
			else if (navigator.appName === 'Netscape') {
				var ua2 = navigator.userAgent;
				var re2  = new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})");
				if (re2.exec(ua2) !== null) {
					rv = parseFloat(RegExp.$1);
				}
			}
		}
		catch(err) {}
		return rv; // IE version as 'number'...
	}

	// used to wire directly on dom elements click, jquery does not work in google maps
	_public.showRoomKey = function() {
		popupRoomKey();
		return true;
	}
	
	// used to wire the map marker bulk available links because the map loads after this runs
	_public.bindMapBulkCalendarLinks = function() {
        bindBulkAvailLinks();
	}

	// Return public methods.
	return _public;

}(window.jQuery));

// Alias as GLOBAL_*_* to protect namespace...
var GLOBAL_SEARCH_RESULTS_PAGE = SearchResultsPage;

/* end of search.js */
/*
 * jQuery FlexSlider v2.2.2
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
;
(function ($) {

  //FlexSlider: Object Instance
  $.flexslider = function(el, options) {
    var slider = $(el);

    // making variables public
    slider.vars = $.extend({}, $.flexslider.defaults, options);

    var namespace = slider.vars.namespace,
        msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,
        touch = (( "ontouchstart" in window ) || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,
        // depricating this idea, as devices are being released with both of these events
        //eventType = (touch) ? "touchend" : "click",
        eventType = "click touchend MSPointerUp keyup",
        watchedEvent = "",
        watchedEventClearTimer,
        vertical = slider.vars.direction === "vertical",
        reverse = slider.vars.reverse,
        carousel = (slider.vars.itemWidth > 0),
        fade = slider.vars.animation === "fade",
        asNav = slider.vars.asNavFor !== "",
        methods = {},
        focused = true;

    // Store a reference to the slider object
    $.data(el, "flexslider", slider);

    // Private slider methods
    methods = {
      init: function() {
        slider.animating = false;
        // Get current slide and make sure it is a number
        slider.currentSlide = parseInt( ( slider.vars.startAt ? slider.vars.startAt : 0), 10 );
        if ( isNaN( slider.currentSlide ) ) slider.currentSlide = 0;
        slider.animatingTo = slider.currentSlide;
        slider.atEnd = (slider.currentSlide === 0 || slider.currentSlide === slider.last);
        slider.containerSelector = slider.vars.selector.substr(0,slider.vars.selector.search(' '));
        slider.slides = $(slider.vars.selector, slider);
        slider.container = $(slider.containerSelector, slider);
        slider.count = slider.slides.length;
        // SYNC:
        slider.syncExists = $(slider.vars.sync).length > 0;
        // SLIDE:
        if (slider.vars.animation === "slide") slider.vars.animation = "swing";
        slider.prop = (vertical) ? "top" : "marginLeft";
        slider.args = {};
        // SLIDESHOW:
        slider.manualPause = false;
        slider.stopped = false;
        //PAUSE WHEN INVISIBLE
        slider.started = false;
        slider.startTimeout = null;
        // TOUCH/USECSS:
        slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && (function() {
          var obj = document.createElement('div'),
              props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
          for (var i in props) {
            if ( obj.style[ props[i] ] !== undefined ) {
              slider.pfx = props[i].replace('Perspective','').toLowerCase();
              slider.prop = "-" + slider.pfx + "-transform";
              return true;
            }
          }
          return false;
        }());
        slider.ensureAnimationEnd = '';
        // CONTROLSCONTAINER:
        if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer);
        // MANUAL:
        if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls);

        // RANDOMIZE:
        if (slider.vars.randomize) {
          slider.slides.sort(function() { return (Math.round(Math.random())-0.5); });
          slider.container.empty().append(slider.slides);
        }

        slider.doMath();

        // INIT
        slider.setup("init");

        // CONTROLNAV:
        if (slider.vars.controlNav) methods.controlNav.setup();

        // DIRECTIONNAV:
        if (slider.vars.directionNav) methods.directionNav.setup();

        // KEYBOARD:
        if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
          $(document).bind('keyup', function(event) {
            var keycode = event.keyCode;
            if (!slider.animating && (keycode === 39 || keycode === 37)) {
              var target = (keycode === 39) ? slider.getTarget('next') :
                           (keycode === 37) ? slider.getTarget('prev') : false;
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }
          });
        }
        // MOUSEWHEEL:
        if (slider.vars.mousewheel) {
          slider.bind('mousewheel', function(event, delta, deltaX, deltaY) {
            event.preventDefault();
            var target = (delta < 0) ? slider.getTarget('next') : slider.getTarget('prev');
            slider.flexAnimate(target, slider.vars.pauseOnAction);
          });
        }

        // PAUSEPLAY
        if (slider.vars.pausePlay) methods.pausePlay.setup();

        //PAUSE WHEN INVISIBLE
        if (slider.vars.slideshow && slider.vars.pauseInvisible) methods.pauseInvisible.init();

        // SLIDSESHOW
        if (slider.vars.slideshow) {
          if (slider.vars.pauseOnHover) {
            slider.hover(function() {
              if (!slider.manualPlay && !slider.manualPause) slider.pause();
            }, function() {
              if (!slider.manualPause && !slider.manualPlay && !slider.stopped) slider.play();
            });
          }
          // initialize animation
          //If we're visible, or we don't use PageVisibility API
          if(!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
            (slider.vars.initDelay > 0) ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();
          }
        }

        // ASNAV:
        if (asNav) methods.asNav.setup();

        // TOUCH
        if (touch && slider.vars.touch) methods.touch();

        // FADE&&SMOOTHHEIGHT || SLIDE:
        if (!fade || (fade && slider.vars.smoothHeight)) $(window).bind("resize orientationchange focus", methods.resize);

        slider.find("img").attr("draggable", "false");

        // API: start() Callback
        setTimeout(function(){
          slider.vars.start(slider);
        }, 200);
      },
      asNav: {
        setup: function() {
          slider.asNav = true;
          slider.animatingTo = Math.floor(slider.currentSlide/slider.move);
          slider.currentItem = slider.currentSlide;
          slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");
          if(!msGesture){
              slider.slides.on(eventType, function(e){
                e.preventDefault();
                var $slide = $(this),
                    target = $slide.index();
                var posFromLeft = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container
                if( posFromLeft <= 0 && $slide.hasClass( namespace + 'active-slide' ) ) {
                  slider.flexAnimate(slider.getTarget("prev"), true);
                } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + "active-slide")) {
                  slider.direction = (slider.currentItem < target) ? "next" : "prev";
                  slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                }
              });
          }else{
              el._slider = slider;
              slider.slides.each(function (){
                  var that = this;
                  that._gesture = new MSGesture();
                  that._gesture.target = that;
                  that.addEventListener("MSPointerDown", function (e){
                      e.preventDefault();
                      if(e.currentTarget._gesture)
                          e.currentTarget._gesture.addPointer(e.pointerId);
                  }, false);
                  that.addEventListener("MSGestureTap", function (e){
                      e.preventDefault();
                      var $slide = $(this),
                          target = $slide.index();
                      if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {
                          slider.direction = (slider.currentItem < target) ? "next" : "prev";
                          slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                      }
                  });
              });
          }
        }
      },
      controlNav: {
        setup: function() {
          if (!slider.manualControls) {
            methods.controlNav.setupPaging();
          } else { // MANUALCONTROLS:
            methods.controlNav.setupManual();
          }
        },
        setupPaging: function() {
          var type = (slider.vars.controlNav === "thumbnails") ? 'control-thumbs' : 'control-paging',
              j = 1,
              item,
              slide;

          slider.controlNavScaffold = $('<ol class="'+ namespace + 'control-nav ' + namespace + type + '"></ol>');

          if (slider.pagingCount > 1) {
            for (var i = 0; i < slider.pagingCount; i++) {
              slide = slider.slides.eq(i);
              item = (slider.vars.controlNav === "thumbnails") ? '<img src="' + slide.attr( 'data-thumb' ) + '"/>' : '<a>' + j + '</a>';
              if ( 'thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions ) {
                var captn = slide.attr( 'data-thumbcaption' );
                if ( '' != captn && undefined != captn ) item += '<span class="' + namespace + 'caption">' + captn + '</span>';
              }
              slider.controlNavScaffold.append('<li>' + item + '</li>');
              j++;
            }
          }

          // CONTROLSCONTAINER:
          (slider.controlsContainer) ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
          methods.controlNav.set();

          methods.controlNav.active();

          slider.controlNavScaffold.delegate('a, img', eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                slider.direction = (target > slider.currentSlide) ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();

          });
        },
        setupManual: function() {
          slider.controlNav = slider.manualControls;
          methods.controlNav.active();

          slider.controlNav.bind(eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                (target > slider.currentSlide) ? slider.direction = "next" : slider.direction = "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        set: function() {
          var selector = (slider.vars.controlNav === "thumbnails") ? 'img' : 'a';
          slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, (slider.controlsContainer) ? slider.controlsContainer : slider);
        },
        active: function() {
          slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
        },
        update: function(action, pos) {
          if (slider.pagingCount > 1 && action === "add") {
            slider.controlNavScaffold.append($('<li><a>' + slider.count + '</a></li>'));
          } else if (slider.pagingCount === 1) {
            slider.controlNavScaffold.find('li').remove();
          } else {
            slider.controlNav.eq(pos).closest('li').remove();
          }
          methods.controlNav.set();
          (slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length) ? slider.update(pos, action) : methods.controlNav.active();
        }
      },
      directionNav: {
        setup: function() {
          var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + '</a></li></ul>');

          // CONTROLSCONTAINER:
          if (slider.controlsContainer) {
            $(slider.controlsContainer).append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
          } else {
            slider.append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
          }

          methods.directionNav.update();

          slider.directionNav.bind(eventType, function(event) {
            event.preventDefault();
            var target;

            if (watchedEvent === "" || watchedEvent === event.type) {
              target = ($(this).hasClass(namespace + 'next')) ? slider.getTarget('next') : slider.getTarget('prev');
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function() {
		
		  if(carousel){
			if(slider.visible < slider.count){
		
			    slider.directionNav.filter('.' + namespace + "next").css('display','block');
				 slider.directionNav.filter('.' + namespace + "prev").css('display','block');
			}else{
			
			   slider.directionNav.filter('.' + namespace + "next").css('display','none');
				 slider.directionNav.filter('.' + namespace + "prev").css('display','none');
			}
		  
		  }
          var disabledClass = namespace + 'disabled';
          if (slider.pagingCount === 1) {
            slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');
          } else if (!slider.vars.animationLoop) {
            if (slider.animatingTo === 0) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "prev").addClass(disabledClass).attr('tabindex', '-1');
            } else if (slider.animatingTo === slider.last) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "next").addClass(disabledClass).attr('tabindex', '-1');
            } else {
              slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
            }
          } else {
            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        }
      },
      pausePlay: {
        setup: function() {
          var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a></a></div>');

          // CONTROLSCONTAINER:
          if (slider.controlsContainer) {
            slider.controlsContainer.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
          } else {
            slider.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
          }

          methods.pausePlay.update((slider.vars.slideshow) ? namespace + 'pause' : namespace + 'play');

          slider.pausePlay.bind(eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              if ($(this).hasClass(namespace + 'pause')) {
                slider.manualPause = true;
                slider.manualPlay = false;
                slider.pause();
              } else {
                slider.manualPause = false;
                slider.manualPlay = true;
                slider.play();
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function(state) {
          (state === "play") ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);
        }
      },
      touch: function() {
        var startX,
          startY,
          offset,
          cwidth,
          dx,
          startT,
          scrolling = false,
          localX = 0,
          localY = 0,
          accDx = 0;

        if(!msGesture){
            el.addEventListener('touchstart', onTouchStart, false);

            function onTouchStart(e) {
              if (slider.animating) {
                e.preventDefault();
              } else if ( ( window.navigator.msPointerEnabled ) || e.touches.length === 1 ) {
                slider.pause();
                // CAROUSEL:
                cwidth = (vertical) ? slider.h : slider.w;
                startT = Number(new Date());
                // CAROUSEL:

                // Local vars for X and Y points.
                localX = e.touches[0].pageX;
                localY = e.touches[0].pageY;

                offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                         (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                         (carousel && slider.currentSlide === slider.last) ? slider.limit :
                         (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                         (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                startX = (vertical) ? localY : localX;
                startY = (vertical) ? localX : localY;

                el.addEventListener('touchmove', onTouchMove, false);
                el.addEventListener('touchend', onTouchEnd, false);
              }
            }

            function onTouchMove(e) {
              // Local vars for X and Y points.

              localX = e.touches[0].pageX;
              localY = e.touches[0].pageY;

              dx = (vertical) ? startX - localY : startX - localX;
              scrolling = (vertical) ? (Math.abs(dx) < Math.abs(localX - startY)) : (Math.abs(dx) < Math.abs(localY - startY));

              var fxms = 500;

              if ( ! scrolling || Number( new Date() ) - startT > fxms ) {
                e.preventDefault();
                if (!fade && slider.transitions) {
                  if (!slider.vars.animationLoop) {
                    dx = dx/((slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0) ? (Math.abs(dx)/cwidth+2) : 1);
                  }
                  slider.setProps(offset + dx, "setTouch");
                }
              }
            }

            function onTouchEnd(e) {
              // finish the touch by undoing the touch session
              el.removeEventListener('touchmove', onTouchMove, false);

              if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                var updateDx = (reverse) ? -dx : dx,
                    target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth/2)) {
                  slider.flexAnimate(target, slider.vars.pauseOnAction);
                } else {
                  if (!fade) slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
              el.removeEventListener('touchend', onTouchEnd, false);

              startX = null;
              startY = null;
              dx = null;
              offset = null;
            }
        }else{
            el.style.msTouchAction = "none";
            el._gesture = new MSGesture();
            el._gesture.target = el;
            el.addEventListener("MSPointerDown", onMSPointerDown, false);
            el._slider = slider;
            el.addEventListener("MSGestureChange", onMSGestureChange, false);
            el.addEventListener("MSGestureEnd", onMSGestureEnd, false);

            function onMSPointerDown(e){
                e.stopPropagation();
                if (slider.animating) {
                    e.preventDefault();
                }else{
                    slider.pause();
                    el._gesture.addPointer(e.pointerId);
                    accDx = 0;
                    cwidth = (vertical) ? slider.h : slider.w;
                    startT = Number(new Date());
                    // CAROUSEL:

                    offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                        (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                            (carousel && slider.currentSlide === slider.last) ? slider.limit :
                                (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                                    (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                }
            }

            function onMSGestureChange(e) {
                e.stopPropagation();
                var slider = e.target._slider;
                if(!slider){
                    return;
                }
                var transX = -e.translationX,
                    transY = -e.translationY;

                //Accumulate translations.
                accDx = accDx + ((vertical) ? transY : transX);
                dx = accDx;
                scrolling = (vertical) ? (Math.abs(accDx) < Math.abs(-transX)) : (Math.abs(accDx) < Math.abs(-transY));

                if(e.detail === e.MSGESTURE_FLAG_INERTIA){
                    setImmediate(function (){
                        el._gesture.stop();
                    });

                    return;
                }

                if (!scrolling || Number(new Date()) - startT > 500) {
                    e.preventDefault();
                    if (!fade && slider.transitions) {
                        if (!slider.vars.animationLoop) {
                            dx = accDx / ((slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0) ? (Math.abs(accDx) / cwidth + 2) : 1);
                        }
                        slider.setProps(offset + dx, "setTouch");
                    }
                }
            }

            function onMSGestureEnd(e) {
                e.stopPropagation();
                var slider = e.target._slider;
                if(!slider){
                    return;
                }
                if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                    var updateDx = (reverse) ? -dx : dx,
                        target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                    if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth/2)) {
                        slider.flexAnimate(target, slider.vars.pauseOnAction);
                    } else {
                        if (!fade) slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                    }
                }

                startX = null;
                startY = null;
                dx = null;
                offset = null;
                accDx = 0;
            }
        }
      },
      resize: function() {
        if (!slider.animating && slider.is(':visible')) {
          if (!carousel) slider.doMath();

          if (fade) {
            // SMOOTH HEIGHT:
            methods.smoothHeight();
          } else if (carousel) { //CAROUSEL:
            slider.slides.width(slider.computedW);
            slider.update(slider.pagingCount);
            slider.setProps();
          }
          else if (vertical) { //VERTICAL:
            slider.viewport.height(slider.h);
            slider.setProps(slider.h, "setTotal");
          } else {
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) methods.smoothHeight();
            slider.newSlides.width(slider.computedW);
            slider.setProps(slider.computedW, "setTotal");
          }
        }
      },
      smoothHeight: function(dur) {
        if (!vertical || fade) {
          var $obj = (fade) ? slider : slider.viewport;
          (dur) ? $obj.animate({"height": slider.slides.eq(slider.animatingTo).height()}, dur) : $obj.height(slider.slides.eq(slider.animatingTo).height());
        }
      },
      sync: function(action) {
        var $obj = $(slider.vars.sync).data("flexslider"),
            target = slider.animatingTo;

        switch (action) {
          case "animate": $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true); break;
          case "play": if (!$obj.playing && !$obj.asNav) { $obj.play(); } break;
          case "pause": $obj.pause(); break;
        }
      },
      uniqueID: function($clone) {
        // Append _clone to current level and children elements with id attributes
        $clone.filter( '[id]' ).add($clone.find( '[id]' )).each(function() {
          var $this = $(this);
          $this.attr( 'id', $this.attr( 'id' ) + '_clone' );
        });
        return $clone;
      },
      pauseInvisible: {
        visProp: null,
        init: function() {
          var prefixes = ['webkit','moz','ms','o'];

          if ('hidden' in document) return 'hidden';
          for (var i = 0; i < prefixes.length; i++) {
            if ((prefixes[i] + 'Hidden') in document)
            methods.pauseInvisible.visProp = prefixes[i] + 'Hidden';
          }
          if (methods.pauseInvisible.visProp) {
            var evtname = methods.pauseInvisible.visProp.replace(/[H|h]idden/,'') + 'visibilitychange';
            document.addEventListener(evtname, function() {
              if (methods.pauseInvisible.isHidden()) {
                if(slider.startTimeout) clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible
                else slider.pause(); //Or just pause
              }
              else {
                if(slider.started) slider.play(); //Initiated before, just play
                else (slider.vars.initDelay > 0) ? setTimeout(slider.play, slider.vars.initDelay) : slider.play(); //Didn't init before: simply init or wait for it
              }
            });
          }
        },
        isHidden: function() {
          return document[methods.pauseInvisible.visProp] || false;
        }
      },
      setToClearWatchedEvent: function() {
        clearTimeout(watchedEventClearTimer);
        watchedEventClearTimer = setTimeout(function() {
          watchedEvent = "";
        }, 3000);
      }
    };

    // public methods
    slider.flexAnimate = function(target, pause, override, withSync, fromNav) {
      if (!slider.vars.animationLoop && target !== slider.currentSlide) {
        slider.direction = (target > slider.currentSlide) ? "next" : "prev";
      }

      if (asNav && slider.pagingCount === 1) slider.direction = (slider.currentItem < target) ? "next" : "prev";

      if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
        if (asNav && withSync) {
          var master = $(slider.vars.asNavFor).data('flexslider');
          slider.atEnd = target === 0 || target === slider.count - 1;
          master.flexAnimate(target, true, false, true, fromNav);
          slider.direction = (slider.currentItem < target) ? "next" : "prev";
          master.direction = slider.direction;

          if (Math.ceil((target + 1)/slider.visible) - 1 !== slider.currentSlide) {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            target = Math.floor(target/slider.visible);
          } else {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            return false;
          }
        }

        slider.animating = true;
        slider.animatingTo = target;

        // SLIDESHOW:
        if (pause) slider.pause();

        // API: before() animation Callback
        slider.vars.before(slider);

        // SYNC:
        if (slider.syncExists && !fromNav) methods.sync("animate");

        // CONTROLNAV
        if (slider.vars.controlNav) methods.controlNav.active();

        // !CAROUSEL:
        // CANDIDATE: slide active class (for add/remove slide)
        if (!carousel) slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');

        // INFINITE LOOP:
        // CANDIDATE: atEnd
        slider.atEnd = target === 0 || target === slider.last;

        // DIRECTIONNAV:
        if (slider.vars.directionNav) methods.directionNav.update();

        if (target === slider.last) {
          // API: end() of cycle Callback
          slider.vars.end(slider);
          // SLIDESHOW && !INFINITE LOOP:
          if (!slider.vars.animationLoop) slider.pause();
        }

        // SLIDE:
        if (!fade) {
          var dimension = (vertical) ? slider.slides.filter(':first').height() : slider.computedW,
              margin, slideString, calcNext;

          // INFINITE LOOP / REVERSE:
          if (carousel) {
            //margin = (slider.vars.itemWidth > slider.w) ? slider.vars.itemMargin * 2 : slider.vars.itemMargin;
            margin = slider.vars.itemMargin;
            calcNext = ((slider.itemW + margin) * slider.move) * slider.animatingTo;
            slideString = (calcNext > slider.limit && slider.visible !== 1) ? slider.limit : calcNext;
          } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
            slideString = (reverse) ? (slider.count + slider.cloneOffset) * dimension : 0;
          } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
            slideString = (reverse) ? 0 : (slider.count + 1) * dimension;
          } else {
            slideString = (reverse) ? ((slider.count - 1) - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
          }
          slider.setProps(slideString, "", slider.vars.animationSpeed);
          if (slider.transitions) {
            if (!slider.vars.animationLoop || !slider.atEnd) {
              slider.animating = false;
              slider.currentSlide = slider.animatingTo;
            }
            
            // Unbind previous transitionEnd events and re-bind new transitionEnd event
            slider.container.unbind("webkitTransitionEnd transitionend");
            slider.container.bind("webkitTransitionEnd transitionend", function() {
              clearTimeout(slider.ensureAnimationEnd);
              slider.wrapup(dimension);
            });

            // Insurance for the ever-so-fickle transitionEnd event
            clearTimeout(slider.ensureAnimationEnd);
            slider.ensureAnimationEnd = setTimeout(function() {
              slider.wrapup(dimension);
            }, slider.vars.animationSpeed + 100);

          } else {
            slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function(){
              slider.wrapup(dimension);
            });
          }
        } else { // FADE:
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeOut(slider.vars.animationSpeed, slider.vars.easing);
            //slider.slides.eq(target).fadeIn(slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

            slider.slides.eq(slider.currentSlide).css({"zIndex": 1}).animate({"opacity": 0}, slider.vars.animationSpeed, slider.vars.easing);
            slider.slides.eq(target).css({"zIndex": 2}).animate({"opacity": 1}, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

          } else {
            slider.slides.eq(slider.currentSlide).css({ "opacity": 0, "zIndex": 1 });
            slider.slides.eq(target).css({ "opacity": 1, "zIndex": 2 });
            slider.wrapup(dimension);
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) methods.smoothHeight(slider.vars.animationSpeed);
      }
    };
    slider.wrapup = function(dimension) {
      // SLIDE:
      if (!fade && !carousel) {
        if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpEnd");
        } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpStart");
        }
      }
      slider.animating = false;
      slider.currentSlide = slider.animatingTo;
      // API: after() animation Callback
      slider.vars.after(slider);
    };

    // SLIDESHOW:
    slider.animateSlides = function() {
      if (!slider.animating && focused ) slider.flexAnimate(slider.getTarget("next"));
    };
    // SLIDESHOW:
    slider.pause = function() {
      clearInterval(slider.animatedSlides);
      slider.animatedSlides = null;
      slider.playing = false;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) methods.pausePlay.update("play");
      // SYNC:
      if (slider.syncExists) methods.sync("pause");
    };
    // SLIDESHOW:
    slider.play = function() {
      if (slider.playing) clearInterval(slider.animatedSlides);
      slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
      slider.started = slider.playing = true;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) methods.pausePlay.update("pause");
      // SYNC:
      if (slider.syncExists) methods.sync("play");
    };
    // STOP:
    slider.stop = function () {
      slider.pause();
      slider.stopped = true;
    };
    slider.canAdvance = function(target, fromNav) {
      // ASNAV:
      var last = (asNav) ? slider.pagingCount - 1 : slider.last;
      return (fromNav) ? true :
             (asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev") ? true :
             (asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next") ? false :
             (target === slider.currentSlide && !asNav) ? false :
             (slider.vars.animationLoop) ? true :
             (slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next") ? false :
             (slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next") ? false :
             true;
    };
    slider.getTarget = function(dir) {
      slider.direction = dir;
      if (dir === "next") {
        return (slider.currentSlide === slider.last) ? 0 : slider.currentSlide + 1;
      } else {
        return (slider.currentSlide === 0) ? slider.last : slider.currentSlide - 1;
      }
    };

    // SLIDE:
    slider.setProps = function(pos, special, dur) {
      var target = (function() {
        var posCheck = (pos) ? pos : ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo,
            posCalc = (function() {
              if (carousel) {
                return (special === "setTouch") ? pos :
                       (reverse && slider.animatingTo === slider.last) ? 0 :
                       (reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                       (slider.animatingTo === slider.last) ? slider.limit : posCheck;
              } else {
                switch (special) {
                  case "setTotal": return (reverse) ? ((slider.count - 1) - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;
                  case "setTouch": return (reverse) ? pos : pos;
                  case "jumpEnd": return (reverse) ? pos : slider.count * pos;
                  case "jumpStart": return (reverse) ? slider.count * pos : pos;
                  default: return pos;
                }
              }
            }());

            return (posCalc * -1) + "px";
          }());

      if (slider.transitions) {
        target = (vertical) ? "translate3d(0," + target + ",0)" : "translate3d(" + target + ",0,0)";
        dur = (dur !== undefined) ? (dur/1000) + "s" : "0s";
        slider.container.css("-" + slider.pfx + "-transition-duration", dur);
         slider.container.css("transition-duration", dur);
      }

      slider.args[slider.prop] = target;
      if (slider.transitions || dur === undefined) slider.container.css(slider.args);

      slider.container.css('transform',target);
    };

    slider.setup = function(type) {
      // SLIDE:
      if (!fade) {
        var sliderOffset, arr;

        if (type === "init") {
          slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({"overflow": "hidden", "position": "relative"}).appendTo(slider).append(slider.container);
          // INFINITE LOOP:
          slider.cloneCount = 0;
          slider.cloneOffset = 0;
          // REVERSE:
          if (reverse) {
            arr = $.makeArray(slider.slides).reverse();
            slider.slides = $(arr);
            slider.container.empty().append(slider.slides);
          }
        }
        // INFINITE LOOP && !CAROUSEL:
        if (slider.vars.animationLoop && !carousel) {
          slider.cloneCount = 2;
          slider.cloneOffset = 1;
          // clear out old clones
          if (type !== "init") slider.container.find('.clone').remove();
          slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true'))
                          .prepend(methods.uniqueID(slider.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'));
        }
        slider.newSlides = $(slider.vars.selector, slider);

        sliderOffset = (reverse) ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset;
        // VERTICAL:
        if (vertical && !carousel) {
          slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
          setTimeout(function(){
            slider.newSlides.css({"display": "block"});
            slider.doMath();
            slider.viewport.height(slider.h);
            slider.setProps(sliderOffset * slider.h, "init");
          }, (type === "init") ? 100 : 0);
        } else {
          slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
          slider.setProps(sliderOffset * slider.computedW, "init");
          setTimeout(function(){
            slider.doMath();
            slider.newSlides.css({"width": slider.computedW, "float": "left", "display": "block"});
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) methods.smoothHeight();
          }, (type === "init") ? 100 : 0);
        }
      } else { // FADE:
        slider.slides.css({"width": "100%", "float": "left", "marginRight": "-100%", "position": "relative"});
        if (type === "init") {
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
            if (slider.vars.fadeFirstSlide == false) {
              slider.slides.css({ "opacity": 0, "display": "block", "zIndex": 1 }).eq(slider.currentSlide).css({"zIndex": 2}).css({"opacity": 1});
            } else {
              slider.slides.css({ "opacity": 0, "display": "block", "zIndex": 1 }).eq(slider.currentSlide).css({"zIndex": 2}).animate({"opacity": 1},slider.vars.animationSpeed,slider.vars.easing);
            }
          } else {
            slider.slides.css({ "display": "block", "zIndex": 0 }).fadeTo(slider.vars.animationSpeed / 1000, 1).eq(slider.currentSlide).css({"opacity": 1, "zIndex": 2});
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) methods.smoothHeight();
      }
      // !CAROUSEL:
      // CANDIDATE: active slide
      if (!carousel) slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");

      //FlexSlider: init() Callback
      slider.vars.init(slider);
    };

    slider.doMath = function() {
      var slide = slider.slides.first(),
          slideMargin = slider.vars.itemMargin,
          minItems = slider.vars.minItems,
          maxItems = slider.vars.maxItems;

      slider.w = (slider.viewport===undefined) ? $(window).width() - 160  : slider.viewport.width();
      slider.h = slide.height();
      slider.boxPadding = slide.outerWidth() - slide.width();

      // CAROUSEL:
      if (carousel) {
        slider.itemT = slider.vars.itemWidth + slideMargin;
        slider.minW = (minItems) ? minItems * slider.itemT : slider.w;
        slider.maxW = (maxItems) ? (maxItems * slider.itemT) - slideMargin : slider.w;
        slider.itemW = (slider.minW > slider.w) ? (slider.w - (slideMargin * (minItems - 1)))/minItems :
                       (slider.maxW < slider.w) ? (slider.w - (slideMargin * (maxItems - 1)))/maxItems :
                       (slider.vars.itemWidth > slider.w) ? slider.w : slider.vars.itemWidth ;
		slider.visible = (Math.floor(slider.w/slider.itemW) > 1) ? Math.floor(slider.w/slider.itemW) - 1 : Math.floor(slider.w/slider.itemW)
        slider.move = (slider.vars.move > 0 && slider.vars.move < slider.visible ) ? slider.vars.move : slider.visible;
        slider.pagingCount = Math.ceil(((slider.count - slider.visible)/slider.move) + 1);
        slider.last =  slider.pagingCount - 1;
        slider.limit = (slider.pagingCount === 1) ? 0 :
                       (slider.vars.itemWidth > slider.w) ? (slider.itemW * (slider.count - 1)) + (slideMargin * (slider.count - 1)) : ((slider.itemW + slideMargin) * slider.count) - slider.w - slideMargin;
      } else {
        slider.itemW = slider.w;
        slider.pagingCount = slider.count;
        slider.last = slider.count - 1;
      }
      slider.computedW = slider.itemW - slider.boxPadding;
    };

    slider.update = function(pos, action) {
      slider.doMath();

      // update currentSlide and slider.animatingTo if necessary
      if (!carousel) {
        if (pos < slider.currentSlide) {
          slider.currentSlide += 1;
        } else if (pos <= slider.currentSlide && pos !== 0) {
          slider.currentSlide -= 1;
        }
        slider.animatingTo = slider.currentSlide;
      }

      // update controlNav
      if (slider.vars.controlNav && !slider.manualControls) {
        if ((action === "add" && !carousel) || slider.pagingCount > slider.controlNav.length) {
          methods.controlNav.update("add");
        } else if ((action === "remove" && !carousel) || slider.pagingCount < slider.controlNav.length) {
          if (carousel && slider.currentSlide > slider.last) {
            slider.currentSlide -= 1;
            slider.animatingTo -= 1;
          }
          methods.controlNav.update("remove", slider.last);
        }
      }
      // update directionNav
      if (slider.vars.directionNav) methods.directionNav.update();

    };

    slider.addSlide = function(obj, pos) {
      var $obj = $(obj);

      slider.count += 1;
      slider.last = slider.count - 1;

      // append new slide
      if (vertical && reverse) {
        (pos !== undefined) ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
      } else {
        (pos !== undefined) ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.update(pos, "add");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      //FlexSlider: added() Callback
      slider.vars.added(slider);
    };
    slider.removeSlide = function(obj) {
      var pos = (isNaN(obj)) ? slider.slides.index($(obj)) : obj;

      // update count
      slider.count -= 1;
      slider.last = slider.count - 1;

      // remove slide
      if (isNaN(obj)) {
        $(obj, slider.slides).remove();
      } else {
        (vertical && reverse) ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.doMath();
      slider.update(pos, "remove");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      // FlexSlider: removed() Callback
      slider.vars.removed(slider);
    };

    //FlexSlider: Initialize
    methods.init();
  };

  // Ensure the slider isn't focussed if the window loses focus.
  $( window ).blur( function ( e ) {
    focused = false;
  }).focus( function ( e ) {
    focused = true;
  });

  //FlexSlider: Default Settings
  $.flexslider.defaults = {
    namespace: "flex-",             //{NEW} String: Prefix string attached to the class of every element generated by the plugin
    selector: ".slides > li",       //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
    animation: "fade",              //String: Select your animation type, "fade" or "slide"
    easing: "swing",                //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
    direction: "horizontal",        //String: Select the sliding direction, "horizontal" or "vertical"
    reverse: false,                 //{NEW} Boolean: Reverse the animation direction
    animationLoop: true,            //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
    smoothHeight: false,            //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
    startAt: 0,                     //Integer: The slide that the slider should start on. Array notation (0 = first slide)
    slideshow: true,                //Boolean: Animate slider automatically
    slideshowSpeed: 7000,           //Integer: Set the speed of the slideshow cycling, in milliseconds
    animationSpeed: 600,            //Integer: Set the speed of animations, in milliseconds
    initDelay: 0,                   //{NEW} Integer: Set an initialization delay, in milliseconds
    randomize: false,               //Boolean: Randomize slide order
    fadeFirstSlide: true,           //Boolean: Fade in the first slide when animation type is "fade"
    thumbCaptions: false,           //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.

    // Usability features
    pauseOnAction: true,            //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
    pauseOnHover: false,            //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
    pauseInvisible: true,   		//{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
    useCSS: true,                   //{NEW} Boolean: Slider will use CSS3 transitions if available
    touch: true,                    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
    video: false,                   //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches

    // Primary Controls
    controlNav: true,               //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage
    directionNav: true,             //Boolean: Create navigation for previous/next navigation? (true/false)
    prevText: "Previous",           //String: Set the text for the "previous" directionNav item
    nextText: "Next",               //String: Set the text for the "next" directionNav item

    // Secondary Navigation
    keyboard: true,                 //Boolean: Allow slider navigating via keyboard left/right keys
    multipleKeyboard: false,        //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
    mousewheel: false,              //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
    pausePlay: false,               //Boolean: Create pause/play dynamic element
    pauseText: "Pause",             //String: Set the text for the "pause" pausePlay item
    playText: "Play",               //String: Set the text for the "play" pausePlay item

    // Special properties
    controlsContainer: "",          //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
    manualControls: "",             //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
    sync: "",                       //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
    asNavFor: "",                   //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider

    // Carousel Options
    itemWidth: 0,                   //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
    itemMargin: 0,                  //{NEW} Integer: Margin between carousel items.
    minItems: 1,                    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
    maxItems: 0,                    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
    move: 0,                        //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
    allowOneSlide: true,           //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide

    // Callback API
    start: function(){},            //Callback: function(slider) - Fires when the slider loads the first slide
    before: function(){},           //Callback: function(slider) - Fires asynchronously with each slider animation
    after: function(){},            //Callback: function(slider) - Fires after each slider animation completes
    end: function(){},              //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
    added: function(){},            //{NEW} Callback: function(slider) - Fires after a slide is added
    removed: function(){},           //{NEW} Callback: function(slider) - Fires after a slide is removed
    init: function() {}             //{NEW} Callback: function(slider) - Fires after the slider is initially setup
  };

  //FlexSlider: Plugin Function
  $.fn.flexslider = function(options) {
    if (options === undefined) options = {};

    if (typeof options === "object") {
      return this.each(function() {
        var $this = $(this),
            selector = (options.selector) ? options.selector : ".slides > li",
            $slides = $this.find(selector);

      if ( ( $slides.length === 1 && options.allowOneSlide === true ) || $slides.length === 0 ) {
          $slides.fadeIn(400);
          if (options.start) options.start($this);
        } else if ($this.data('flexslider') === undefined) {
          new $.flexslider(this, options);
        }
      });
    } else {
      // Helper strings to quickly perform functions on the slider
      var $slider = $(this).data('flexslider');
      switch (options) {
        case "play": $slider.play(); break;
        case "pause": $slider.pause(); break;
        case "stop": $slider.stop(); break;
        case "next": $slider.flexAnimate($slider.getTarget("next"), true); break;
        case "prev":
        case "previous": $slider.flexAnimate($slider.getTarget("prev"), true); break;
        default: if (typeof options === "number") $slider.flexAnimate(options, true);
      }
    }
  };
})(jQuery);
/*
	This file needs to be moved into Webcommons, Idea is to use this class for Search results page too.
 */

/* Setting up Flexslider on  the page */
jQuery(document).ready(function(){
	jQuery('body').on('click', '.photoViewerWrapper', function(event){		
		try{
		event.stopPropagation();
		var photoData = [];
				
		jQuery(this).find('ol.photoURL li').each(function(){
			var photoInfo = {};
			photoInfo.url = jQuery.trim(jQuery(this).text());
			photoInfo.category=jQuery.trim(jQuery(this).attr('data-photo-category'));
			photoInfo.roomDesc=jQuery.trim(jQuery(this).attr('data-room-description'));
			photoInfo.caption=jQuery.trim(jQuery(this).attr('data-photo-caption'));
			photoInfo.type=jQuery.trim(jQuery(this).attr('data-photo-type'));
			photoInfo.assetCounterText=jQuery.trim(jQuery(this).attr('data-asset-counter'));
			photoInfo.virtualTour360=jQuery.trim(jQuery(this).attr('data-virtualtour-text'));
			photoInfo.interact360=jQuery.trim(jQuery(this).attr('data-interact-text'));
			photoInfo.dragDirection360=jQuery.trim(jQuery(this).attr('data-dragdirection-text'));
			photoInfo.languageId = jQuery.trim(jQuery(this).attr('data-language-id'));
			photoData.push(photoInfo);
		});

		var targetSlider = jQuery(this).attr('data-slider-target');
		var targetThumbnails = jQuery(this).attr('data-carousel-target');
		var container = jQuery(this).attr('data-container-target');

		
			IHGflexslider.launchFlexSlider(photoData, '#'+targetSlider, '#'+targetThumbnails, '#'+container);
		}catch(e){
			IHGflexslider.TRACE("Exception occured flex slider : when view gallery is clicked ::: " + e);
		}
		return false;
	});

	jQuery('body').on('click', '.flexslider > .flexSliderclose', function(event){
		try{
		jQuery('body').off('touchmove');
		event.stopPropagation(); // This works on all modern browsers except the other browser still cathing up.
		IHGflexslider.closeIHGflexSlider(jQuery(this));
		}catch(e){
			IHGflexslider.TRACE("Exception occured flex slider : while trying to close flex slider");
			var closeElement = jQuery(this);
			var container = closeElement.closest('.flexsliderContainer');
			container.addClass("hide");
			jQuery("html").removeAttr("style");
		}
		return false; // This is for the old browsers.
	});

	if (IHGflexslider.isIPad()) { /* Trigger resize event for iPads */
		try{
			window.document.addEventListener('orientationchange', function(){
				IHGflexslider.resizeGallery();
			}, false);
		}catch(e){
			IHGflexslider.TRACE("Exception occured flex slider : orientation change");
		}
	} else { /* Trigger resize event for Desktop */
	jQuery(window).resize(function(){
		try{
		IHGflexslider.resizeGallery();
		}catch(e){
			IHGflexslider.TRACE("Exception occured flex slider : while trying to resize the window");
		}
	});
	}



	jQuery(document).keyup(function(e) {
		  if (e.keyCode == 27) {
				try{
			  jQuery('.flexsliderContainer:not(.hide)').each(function(){
				  IHGflexslider.closeIHGflexSlider(jQuery(this).find('.flexslider > .flexSliderclose'));
			  });
			} catch (e) {
					IHGflexslider.TRACE("Exception occured flex slider : while trying to close flex slider");
					  jQuery('.flexsliderContainer:not(.hide)').each(function(){
							var closeElement = jQuery(this).find('.flexslider > .flexSliderclose');
							var container = closeElement.closest('.flexsliderContainer');
							container.addClass("hide");
							jQuery("html").removeAttr("style");});
			}
		  }

		});
});
/* End setting up Flexslider on the page */

/* General functions Starts here */
var arrow_keys_handler = function(e) {
	try{
    switch(e.keyCode){
    	case 9: // Tab key
    	case 37: case 39: case 38:  case 40: // Arrow keys
    	case 33: case 34: case 35: case 36: //Home, End, Page up and Down keys
        case 32: e.preventDefault(); break; // Space
        default: break; // do not block other keys
    }
	} catch (e) {
		IHGflexslider.TRACE("Exception occured flex slider : Arrow Keys Handler");
	}
};

var disable_mouse = function(e){
	e.preventDefault();
}
/* General functions Starts here */

var IHGflexslider = (function() { 
	var currentScrollPos = 0;
	var _private = {

		TRACE: function TRACE(message) {
			if (window.console && window.console.log) {
				window.console.log(message);
			}
		},
		
		isIPad: function isIPad() {
			return navigator.userAgent.match(/iPad/i);
		},
	
		launchFlexSlider: function launchFlexSlider(sliderArray, sliderElementId, carouselElementId, containerElementId) {
			
			var invalidImgCarouselPlaceHolder 	= "/content/dam/etc/media_library/branded/cn/en/us/res/images/NoImageAvailable_RoomRates.png";
			var invalidImgSliderPlaceHolder 	= "/content/dam/etc/media_library/branded/cn/en/us/res/images/NoImageAvailable_FlexSlider.png";
			
			var sliderElement = jQuery(sliderElementId);
			var carouselElement = jQuery(carouselElementId);	 
			
			var prevTxtMsg = jQuery('input#prevItemTxt').val();
			var nextTxtMsg = jQuery('input#nextItemTxt').val();
	
			if (sliderArray && sliderArray instanceof Array && sliderArray.length > 0) {			
				if(sliderElement.hasClass('active')){
					_private.enableFullScreen(sliderElement, carouselElement, containerElementId, sliderArray.length > 1);
					jQuery(carouselElementId).find('ul.slides > li:first').find('img').click(); // Trigger a click event on the first element.
				}else if (sliderElement) {
					for ( var i = 0; i < sliderArray.length; i++) {
						if(sliderArray[i]){
							// Loading Carousel images first.
							if(sliderArray[i].type === '360'){
								carouselElement.find('ul.slides').append(
										'<li>' +
											'<div>' +
												'<img src=' + sliderArray[i].url + '?wid=' + 120 +'></img>' +
												'<span class="cue360Image" data-slnm-ihg="cue360ImageSID"></span>' +
											'</div>' +
										'</li>');
							}else{
								carouselElement.find('ul.slides').append("<li><img src=" + sliderArray[i].url + '?wid=' + 120 +"></img></li>");
							}
	
							// Next add up all the Main images
							var formedli = "<li>";
							var endli = "</li>";
							var imageTag;
							var photoCaptionTag;
							if(sliderArray[i].type === '360'){
								photoCaptionTag = '<div class="photoCaption for360">';
								imageTag = '<img class="360image" src=' + sliderArray[i].url + "?op_sharpen=1></img>";
								formedli = formedli +
								    '<div class="room-virtualtour">' +
										'<div class="room-image-rotate">' +
											'<div id="iconFor360Asset" class="iconFor360View" data-slnm-ihg="iconFor360ViewSID">' +
												'<div class="infoTxt360" data-slnm-ihg="infoTxt360SID">' +
													'<span class="virtualTxt360" data-slnm-ihg="virtualTxt360SID">' + sliderArray[i].virtualTour360 + '</span>\n' +
													'<span class="interact360" data-slnm-ihg="interact360SID">' + sliderArray[i].interact360 + '</span>\n' +
													'<span class="dragDirection360" data-slnm-ihg="dragDirection360SID">' + sliderArray[i].dragDirection360 + '</span>' +
												'</div>' +
											'</div>' +
											imageTag +
										'</div>' +
										'<div class="zoomIconContainer ' + sliderArray[i].languageId +' ">' +
											'<input type="button" class="zoomIcon zoomInIcon"  title="Zoom In">' +
											'<input type="button" class="zoomIcon zoomOutIcon" title="Zoom Out">' +
										'</div>' +
									'</div>';
							}else{
								photoCaptionTag = '<div class="photoCaption">';
								if(i < 2){
									imageTag = '<img src=' + sliderArray[i].url + "?op_sharpen=1&bgc=000&scale=5&hei=3000&wid=4000></img>";
								}else{
									imageTag = '<img src=\'\' srcHolder=' + sliderArray[i].url + "?op_sharpen=1&bgc=000&scale=5&hei=3000&wid=4000></img>";
								}
	
								formedli = formedli + imageTag;
							}
	
							photoCaptionTag =  photoCaptionTag + '<div class="roomDescPhoto ' + sliderArray[i].languageId +'">' + sliderArray[i].roomDesc + sliderArray[i].category + '<span class="assetCounterPhoto ' + sliderArray[i].languageId +'">' + sliderArray[i].assetCounterText + '</span></div>' +  '<div class="shortCaptionPhoto ' + sliderArray[i].languageId +'">' + sliderArray[i].caption  + '</div>'  +'</div>';
	
							formedli = formedli + photoCaptionTag + endli;
							sliderElement.find('ul.slides').append(formedli);
						}
					}
	
					sliderElement.closest(containerElementId).detach().appendTo('body');
	
	
					if(sliderArray.length > 1){
	
						// Launch slider
						carouselElement.flexslider({
							asNavFor: sliderElementId,
							animation: "slide",
							itemWidth: 110,
							itemMargin: 20,
						    prevText : "",
							nextText : "",
				// setting controlNav to true - this is a workaround fix for bug in flexslider where during resize of browser carousel becomes empty
							controlNav: true,
						    animationLoop: false,
						    slideshow: false
						});
	
						sliderElement.flexslider({
							prevText : "",
							nextText : "",
							animationSpeed: 1500,
							slideshow: false,
							animationLoop: false,
							sync: carouselElementId,
							after: _private.loadNextImage
						});
	
	
					}else{
						sliderElement.flexslider({
							prevText : "",
							nextText : "",
							animationLoop: false,
							slideshow: false
						});
	
						sliderElement.find('.flex-direction-nav').addClass('hide');
						carouselElement.addClass('hide');
						sliderElement.css('height', '99%');
					}

                    /** Remove the unloaded photos from the Slider **/
                    carouselElement.find('ul.slides').find('li').each(function(index){
                            var liElemet = jQuery(this);
                            jQuery(this).find('img').error(function(){
                                            jQuery(this).attr('src',invalidImgCarouselPlaceHolder);

                                            var sliderliElement   = sliderElement.find('ul.slides').find('li').eq(index);
                                            var sliderImgElement  = sliderliElement.find('img');
                                            if(sliderliElement.find('.img-con-360-img-con').attr('class')){
                                                    var imgHTML = '<img src="" srcHolder="' + invalidImgSliderPlaceHolder +'?op_sharpen=1&bgc=000&scale=5&hei=3000&wid=4000"/>';
                                                            sliderliElement.find('.room-image-rotate').remove();
                                                            sliderliElement.find('.room-virtualtour').remove();
                                                            sliderliElement.find('.photoCaption').removeClass('for360');
                                                            sliderliElement.prepend(imgHTML);
                                                            _private.updatedCoordinates(sliderElement, carouselElement, containerElementId, sliderArray.length > 1);
                                            }else{
                                                    sliderImgElement.attr('src',invalidImgSliderPlaceHolder);
                                            }


                            });
                    });

					sliderElement.addClass('active');
	                jQuery(containerElementId).find('.flex-next').attr('title',nextTxtMsg);
	                jQuery(containerElementId).find('.flex-prev').attr('title',prevTxtMsg);
	                jQuery(containerElementId).find('.flex-next').attr('data-slnm-ihg',"flexNextSID");
	                jQuery(containerElementId).find('.flex-prev').attr('data-slnm-ihg',"flexPrevSID");
					_private.enableFullScreen(sliderElement, carouselElement, containerElementId, sliderArray.length > 1);
	
				}
			}
		},
	
		enableFullScreen: function enableFullScreen(sliderElement, carouselElement, containerElementId, multipleImages) {
			var offset = _private.getCurrentOffset();
	
			_private.updatedCoordinates(sliderElement, carouselElement, containerElementId, multipleImages);
	
			jQuery(containerElementId).removeClass('hide');
			jQuery(containerElementId).css('top', offset[1]);
	
			_private.attach360Viewer(sliderElement);
	
			// TODO: Move this into a different method
			jQuery("html").css("overflow", "hidden");
			window.addEventListener("keydown", arrow_keys_handler, false);
			window.addEventListener("DOMMouseScroll", disable_mouse, false);
			window.onmousewheel = document.onmousewheel = disable_mouse;
			window.onmousedown = disable_mouse;
			jQuery('body').on('touchmove', function(e){e.preventDefault();});
		},
	
		updatedCoordinates: function updatedCoordinates(sliderElement, carouselElement, containerElementId, multipleImages){
			if (_private.isIPad()) { /* iPad */
				var scrnWidth =  window.innerWidth + 10 ; // Adding this 10 for scroll bar items.
				var scrnHeight = window.innerHeight; 
			} else { /* Desktop */
			var scrnWidth =  jQuery(window).width() + 9 ; // Adding this 9 for scroll bar items.
			var scrnHeight = jQuery(window).height();
			}
			var scrnHeight90 = Math.round(scrnHeight - 86); // Leave the height for Thumbnails
	
			var imageWidth=0;
	
			if(multipleImages){
				imageWidth = Math.round((scrnHeight90/3) *4);
			}else{
				imageWidth = Math.round((scrnHeight/3) * 4);
			}
	
			carouselHeight = 86; // Adding 4 to accommodate border;
	
			jQuery(containerElementId).css('width', scrnWidth);
			jQuery(containerElementId).css('height', scrnHeight);
	
			jQuery(sliderElement).css('width', scrnWidth);
	
			jQuery(sliderElement).find('img.360image').css('width', scrnWidth);
			jQuery(sliderElement).find('img').not('.360image').css('width', imageWidth);
	
			if(multipleImages){
				jQuery(sliderElement).css('height', scrnHeight90);
				jQuery(sliderElement).find('img').not('.360image').css('height', scrnHeight90);
				jQuery(sliderElement).find('img.360image').css('height', scrnHeight90-40);
				jQuery(carouselElement).css('width', scrnWidth);
				jQuery(carouselElement).css('height', carouselHeight);
			}else{
				jQuery(sliderElement).css('height', scrnHeight);
				jQuery(sliderElement).find('img').not('.360image').css('height', scrnHeight + 12); // add 12 px to cover up some borders;
				jQuery(sliderElement).find('img.360image').css('height', scrnHeight-40);
			}
		},
	
		getCurrentOffset: function getCurrentOffset() {
			var scrOfX = 0, scrOfY = 0;
			if (typeof (window.pageYOffset) == 'number') {
				// Netscape compliant
				scrOfY = window.pageYOffset;
				scrOfX = window.pageXOffset;
			} else if (document.body
					&& (document.body.scrollLeft || document.body.scrollTop)) {
				// DOM compliant
				scrOfY = document.body.scrollTop;
				scrOfX = document.body.scrollLeft;
			} else if (document.documentElement
					&& (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {
				// IE6 standards compliant mode
				scrOfY = document.documentElement.scrollTop;
				scrOfX = document.documentElement.scrollLeft;
			}
			return [ scrOfX, scrOfY ];
		},
	
		initPanoramicView: function initPanoramicView(panorama) {
			// Assign image object from given container
			var $img = panorama.find('img');
	
	
			// this is for animation wrapper width calculation
			var numImgCount = 50;
	
			// assign path of the image to use background image of animation wrapper
			var imgSrc = $img.attr('src');
	
			// get the image height and width of given container
			var $imgh = $img.height(),
			    $imgw = $img.width();
	
			// declaration for mouse move and animation direction and speed
			// calculation
			var xposCon = panorama.offset();
				xposCon = xposCon.left;
	
	
			// added class and style for given container
			panorama.addClass('img-con-360');
			panorama.css({"height":$imgh + "px","width":Math.round($imgw/2) + "px" });
	
			// wrap the image tag with animation wrapper and apply the style for
			// created animation wrapper
			panorama.find('img').wrapAll( "<div class='img-con-360-img-con'></div>" );
			var twidth = $imgw * numImgCount;
			panorama.find('.img-con-360-img-con').css({'width':($imgw) + "px", "height":$imgh + "px","background-size" : "auto " + $imgh +"px" ,"background-image":"url(" + imgSrc + ")"});
			panorama.find('.img-con-360-img-con > .imageWrapper').css({'width' :$imgw + 'px', 'height':$imgh + 'px'});
		},
	
		loadNextImage: function loadNextImage(element){
			/*
			element.find('li').each(function(){
				var imgElement =  jQuery(this).find('img');
				imgElement.attr('src', imgElement.attr('srcHolder'));
			});
			*/
	
			/* Load each element as the user clicks on Next arrow
			 *
			 * If the user clicks on the thumbnail then load the current image and then load the Next image
			 *
			 * */
			try{
			var activeImageElement = element.find('li.flex-active-slide > img');
			var imgElement = element.find('li.flex-active-slide').next().find('img');
	
			//Update the current image if it's not been loaded
			if(activeImageElement != undefined && activeImageElement.attr('src') === ''){
				activeImageElement.attr('src', activeImageElement.attr('srcHolder'));
			}
	
			if(imgElement != undefined  && imgElement.attr('src') === ''){
				imgElement.attr('src' , imgElement.attr('srcHolder'));
			}
			}catch(e){
				_private.TRACE("Exception occured flex slider : Load Next Image");
			}
		},
	
		resizeGallery: function resizeGallery() {
			/* Call this method everytime the window is been resized */
			jQuery('.photoViewerWrapper').each(function(){
				var targetSlider = jQuery(this).attr('data-slider-target');
				var targetThumbnails = jQuery(this).attr('data-carousel-target');
				var container = jQuery(this).attr('data-container-target');
	
				if(jQuery('#'+targetSlider).hasClass('active')){
					var sliderArray = jQuery('#'+targetSlider).find('ul.slides > li');
					_private.updatedCoordinates(jQuery('#'+targetSlider), jQuery('#'+targetThumbnails), container, sliderArray.length > 1);
	
					jQuery('#'+container).find('.room-image-rotate').each(function(){
						_private.pauseAnimate360Image(jQuery(this).find('.img-con-360-img-con'));
					});
					_private.attach360Viewer(jQuery('#'+targetSlider));
				}
			});
		},
	
	
		attach360Viewer: function attach360Viewer(sliderElement) {
			sliderElement.find('.room-virtualtour').each(function() {
	            // TODO no magic numbers, move these to some config.js somewhere
	            var baseScaleFactor = 1.5,  // default scaling factor
	            	deltaScaleFactor = 0.5,  // how radical is zoom in/out
	            	maxZoomLevel = 5,
	            	minZoomLevel = 2;
	            var zoomLevel = 2;
	
	            var parentContainer = jQuery(this);
	            parentContainer.find('.zoomIconContainer').addClass('hide');
	            var container360 = parentContainer.find('.room-image-rotate');
	
				var rescale = function(zoomLevel) {
					// update 360 image to reflect desired zoom level
					var scaleValue = baseScaleFactor + deltaScaleFactor * (zoomLevel - minZoomLevel);
					return container360.find('.img-con-360-img-con').css({
						'margin-top': '20px',  // yes, reinforce this with each zoom level change
						'transform': 'scale(' + scaleValue + ',' + scaleValue + ')'
					});
				};
	
				if(!container360.hasClass('img-con-360')) { // if the player is not initialized. Let's do it now.
					_private.initPanoramicView(container360);
				} // Otherwise Just activate it
	
	            container360.find('.img-con-360-img-con').cyclotron({autorotation:1, dampingFactor:1, continuous: 1});
	
	            container360.find('.img-con-360-img-con').on('click', function(ev) {
					jQuery(this).css({
						opacity: 1
					});
					container360.find('.iconFor360View').hide();
	                parentContainer.find('.zoomIconContainer').removeClass('hide');
				});
	            parentContainer.find('.zoomInIcon').on('click',function(ev) {
	            	if(zoomLevel < maxZoomLevel) {
						zoomLevel += 1;
						rescale(zoomLevel);
	            	}
	            });
	            parentContainer.find('.zoomOutIcon').on('click',function(ev) {
	            	if(zoomLevel > minZoomLevel) {
	                	zoomLevel -= 1;
						rescale(zoomLevel);
	               	}
	            });
			});
		},
	
		closeIHGflexSlider: function closeIHGflexSlider(closeElement) {
			var container = closeElement.closest('.flexsliderContainer');
			container.addClass("hide");
	
			// reset active slide when the slider is closed
			if(container.find('.flex-active-slide').length > 1){		
				container.find('.flex-active-slide').each(function(){
					jQuery(this).removeClass('flex-active-slide');
				});					
			} 
	
			if(container.find('.room-virtualtour').length > 0){
				container.find('.room-virtualtour').each(function(){
					_private.pauseAnimate360Image(jQuery(this).find('.room-image-rotate').find('.img-con-360-img-con'));
				});
			}
	
	
			jQuery("html").removeAttr("style");
			window.removeEventListener("keydown", arrow_keys_handler, false);
			window.removeEventListener("DOMMouseScroll", disable_mouse, false);
			window.onmousewheel = document.onmousewheel = null;
			window.onmousedown = null;
			if (_private.isIPad()) { /* iPad */
				setTimeout(function(){
					// Fix for DE1096 where for MapView where scrolling the map yield incorrect coordinates. As such 
					// scroll to top had occurred when the flexslider was launched, and here we now
					// scroll back to where we were before the slider launched.
					jQuery(window).scrollTop(currentScrollPos);
					currentScrollPos = 0;
				},5);
			}
		},
	
		pauseAnimate360Image: function pauseAnimate360Image(elementToAnimate){
			try{
			//Remove the sliding effect fron the element.
			var parent = elementToAnimate.closest('.room-image-rotate');
			jQuery(elementToAnimate).prev().css('display','block');
			elementToAnimate.find('img').clone().appendTo(parent);
			elementToAnimate.remove();
			parent.removeClass('img-con-360');
			}catch(e){
				_private.TRACE("Exception occured flex slider : Pause Animate 360 Image");
			}
	
		},
		
        initFlexSliderImgErrorHandler: function initFlexSliderImgErrorHandler(addClassNames,removeClassName) {
            jQuery('body').find('.photoViewerWrapper > img').error(function(){
            var url = jQuery(this).attr('src').split('?')[0];
            var imageElement = jQuery(this);
            var liElement = jQuery(this).parent();
            jQuery(this).parent().find('ol.photoURL li').each(function(){
            if(jQuery(this).html().indexOf(url) != -1){
            	var photoURLOlLiSize = liElement.find('ol.photoURL li').size();	
                            if(photoURLOlLiSize == 1){
                                var divElement = '<div class="' + addClassNames + '" />';
                                imageElement.parent().removeClass(removeClassName);
                                imageElement.parent().html(divElement);
                            }
                            jQuery(this).remove();
            			}else{
                            imageElement.attr('src',jQuery(this).html() + '?wid=230' );
                            return false; 
            			}

            		});
            	});

           }
		
	};

	function invokePrivate(callee, methodArgs) {
		try {
			var funcName = callee.match(/function ([^\(]+)/)[1];
			_private[funcName].apply(_private, methodArgs);
		}catch(e){
			_private.TRACE("Exception occured in flex slider. Flex slider will now be closed. Method invoked was " + funcName + " ::: " + e);
			if (jQuery && jQuery('html') && jQuery('body') && jQuery('.flexsliderContainer')) {
				jQuery('.flexsliderContainer').addClass('hide'); // hide all flexsliders in case of any issues.
				jQuery('html').removeAttr('style');
				jQuery('body').off('touchmove'); // remove the No-OP touchmove handler that was added when entering fullscreen 
			} else {
				_private.TRACE("Unable to close flex slider. Page will now be refreshed.");
				location.reload(false); // 'false' to load from browser cache, not the server (just to make sure that we don't flood the server)
			}
		}
	};

	function launchFlexSlider(sliderArray, sliderElementId, carouselElementId, containerElementId) {
		try {
			if (_private.isIPad()) { /* iPad */
				// Fix for DE1096 where for MapView where scrolling the map yield incorrect coordinates. As such 
				// scroll to top on flexslider launch and then restore scroll position on flexslider close.
				currentScrollPos = jQuery(window).scrollTop();
				jQuery(window).scrollTop(0);
				var origCallee = arguments.callee.toString();
				var origArgs = arguments;
				setTimeout(function(){
					invokePrivate(origCallee , origArgs);
				},5);
			} else { /* desktop */
				invokePrivate(arguments.callee.toString(), arguments);
			}
		}catch(e){
			_private.TRACE("Exception occured flex slider : when launchFlexSlider was invoked ::: " + e);
		}
	};

	function closeIHGflexSlider(closeElement) {
		invokePrivate(arguments.callee.toString(), arguments);
	};

	function resizeGallery() {
		invokePrivate(arguments.callee.toString(), arguments);
	};

    function initFlexSliderImgErrorHandler(addClassNames,removeClassName){
        invokePrivate(arguments.callee.toString(), arguments);
    };


	
	return {

	TRACE: _private.TRACE,
	
	isIPad: _private.isIPad,

	launchFlexSlider: launchFlexSlider,

	closeIHGflexSlider: closeIHGflexSlider,

	resizeGallery: resizeGallery,
	
	initFlexSliderImgErrorHandler: initFlexSliderImgErrorHandler

}}());
/*
  
  # jquery.cyclotron.js

  You can see how it works at the [demo page](http://quelbs.github.com/cyclotron/).

 */
(function ($) {
	$.fn.cyclotron = function (options) {
		return this.each(function () {
			var container, sx, dx = 0, armed, offsetposition = 0, tick, prev, prevy, h = [], max=0, min=0;
			container = $(this);
			var settings = $.extend({
				dampingFactor: 0.93,
				historySize: 5,
				autorotation: 1,
				continuous: 1
			}, options);
			// check for dampingFactor in range
			if((settings.dampingFactor>1 || settings.dampingFactor<0)) {
				if (typeof console==='object') {
					console.log('dampingFactor out of range '+settings.dampingFactor);
				}
				settings.dampingFactor=0.93;
			}
			// check for nonContinuous class to set continuous to 0 if existing
			if(settings.continuous===1 && container.hasClass('nonContinuous')) {
				settings.continuous=0;	
			}
			// check size of image if not continuous image
			if(settings.continuous===0) {
				var image_url = container.css('background-image').replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
				var image = new Image();
				$(image).load(function () {
					max=image.width - container.width();
				});
				image.src = image_url;
			}
			// set autorotation
			if(settings.autorotation!=0) {
				armed=false;
				dx=settings.autorotation;
			}
			container.bind('touchstart mousedown', function (e) {
				var px = (e.pageX>0?e.pageX:e.originalEvent.touches[0].pageX);
				sx = px - offsetposition;
				armed = true;
				e.preventDefault();
			});
			container.bind('touchmove mousemove', function (e) {	
				if (armed) {
					var px = (e.pageX>0?e.pageX:e.originalEvent.touches[0].pageX);
					var py = (e.pageY>0?e.pageY:e.originalEvent.touches[0].pageY);
					if(typeof prevy==='undefined'){
						prevy = py;	
					}
					if (typeof prev==='undefined') {
						prev = px;
					}
					offsetposition = px - sx;
					if (h.length > settings.historySize) {
						h.shift();
					}
					h.push(prev - px);
					checkoffsetposition();
					container.css('background-position', offsetposition);
					prev = px;
					var currentMargin = container.css('margin-top').match( /\d+/g );
					var matrixRegex   = /matrix\((-?\d*\.?\d+),\s*0,\s*0,\s*(-?\d*\.?\d+),\s*0,\s*0\)/;
					var scaleMatrix   =  container.css('transform').match(matrixRegex);
					if (py - prevy > 3) {
						container.css('margin-top',parseInt(currentMargin) - 2 + 'px');
					} else if (prevy - py > 3) {
							if ((scaleMatrix[1] == 3 && currentMargin <= 460)
														|| (scaleMatrix[1] == 2.5 && currentMargin <= 330)
														|| (scaleMatrix[1] == 2 && currentMargin <= 190)
														|| (scaleMatrix[1] == 1.5 && currentMargin <= 30)) {
													container.css('margin-top',parseInt(currentMargin) + 2 + 'px');
							} else if (currentMargin <= 30) {
													container.css('margin-top',parseInt(currentMargin) + 2 + 'px');
							}
					}
					prevy = py;
				}
			});
			container.bind('mouseleave mouseup touchend', function () {
				if (armed) {
					var len = h.length, v = h[len - 1];
					for (var i = 0; i < len; i++) {
						v = (v * len + (h[i])) / (len + 1);
					}
					dx = v;
				}
				armed = false;
			});
			tick = function () {
				if (!armed && dx) {
					dx *= settings.dampingFactor;
					offsetposition -= dx;
					checkoffsetposition();
					container.css('background-position', offsetposition);
					if (Math.abs(dx) < 0.001) {
						dx = 0;
					}
				}
			};
			// shim layer with setTimeout fallback
			window.requestAnimFrame = (function () {
					return window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.oRequestAnimationFrame ||
					window.msRequestAnimationFrame ||
					function (callback) {
						// use 16.666 ms for better performance in older browsers
						window.setTimeout(callback, 100/6);
					};
			})();
			// the equivalent of setInterval(tick, 16);
			(function animloop(){
				requestAnimFrame(animloop);
				tick();
			})();
			function checkoffsetposition() {
				if(settings.continuous===0) {
					if (-offsetposition<min) {
						dx=0;
						offsetposition=-min;
					}
					if (-offsetposition>max) {
						dx=0;
						offsetposition=-max;
					}
				}
			}
		});
	};
}(jQuery));
/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-input-inputtypes-shiv-cssclasses-load
 */
;window.Modernizr=function(a,b,c){function v(a){j.cssText=a}function w(a,b){return v(prefixes.join(a+";")+(b||""))}function x(a,b){return typeof a===b}function y(a,b){return!!~(""+a).indexOf(b)}function z(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:x(f,"function")?f.bind(d||b):f}return!1}function A(){e.input=function(c){for(var d=0,e=c.length;d<e;d++)p[c[d]]=c[d]in k;return p.list&&(p.list=!!b.createElement("datalist")&&!!a.HTMLDataListElement),p}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),e.inputtypes=function(a){for(var d=0,e,f,h,i=a.length;d<i;d++)k.setAttribute("type",f=a[d]),e=k.type!=="text",e&&(k.value=l,k.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(f)&&k.style.WebkitAppearance!==c?(g.appendChild(k),h=b.defaultView,e=h.getComputedStyle&&h.getComputedStyle(k,null).WebkitAppearance!=="textfield"&&k.offsetHeight!==0,g.removeChild(k)):/^(search|tel)$/.test(f)||(/^(url|email)$/.test(f)?e=k.checkValidity&&k.checkValidity()===!1:e=k.value!=l)),o[a[d]]=!!e;return o}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var d="2.8.3",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k=b.createElement("input"),l=":)",m={}.toString,n={},o={},p={},q=[],r=q.slice,s,t={}.hasOwnProperty,u;!x(t,"undefined")&&!x(t.call,"undefined")?u=function(a,b){return t.call(a,b)}:u=function(a,b){return b in a&&x(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=r.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(r.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(r.call(arguments)))};return e});for(var B in n)u(n,B)&&(s=B.toLowerCase(),e[s]=n[B](),q.push((e[s]?"":"no-")+s));return e.input||A(),e.addTest=function(a,b){if(typeof a=="object")for(var d in a)u(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},v(""),i=k=null,function(a,b){function l(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function m(){var a=s.elements;return typeof a=="string"?a.split(" "):a}function n(a){var b=j[a[h]];return b||(b={},i++,a[h]=i,j[i]=b),b}function o(a,c,d){c||(c=b);if(k)return c.createElement(a);d||(d=n(c));var g;return d.cache[a]?g=d.cache[a].cloneNode():f.test(a)?g=(d.cache[a]=d.createElem(a)).cloneNode():g=d.createElem(a),g.canHaveChildren&&!e.test(a)&&!g.tagUrn?d.frag.appendChild(g):g}function p(a,c){a||(a=b);if(k)return a.createDocumentFragment();c=c||n(a);var d=c.frag.cloneNode(),e=0,f=m(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function q(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?o(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function r(a){a||(a=b);var c=n(a);return s.shivCSS&&!g&&!c.hasCSS&&(c.hasCSS=!!l(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||q(a,c),a}var c="3.7.0",d=a.html5||{},e=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,f=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g,h="_html5shiv",i=0,j={},k;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",g="hidden"in a,k=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){g=!0,k=!0}})();var s={elements:d.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:c,shivCSS:d.shivCSS!==!1,supportsUnknownElements:k,shivMethods:d.shivMethods!==!1,type:"default",shivDocument:r,createElement:o,createDocumentFragment:p};a.html5=s,r(b)}(this,b),e._version=d,g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+q.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))};
var inputSupportList = {"number": Modernizr.inputtypes.number, "email": Modernizr.inputtypes.email, "tel": Modernizr.inputtypes.tel};
var attributeSupportList = {"pattern": Modernizr.input.pattern};
var plataformSupportList = {"ipad": navigator.platform.toLowerCase().indexOf("ipad") != -1, "android": navigator.userAgent.toLowerCase().indexOf("android") != -1};

jQuery(document).ready(performProtection);
jQuery(document).ajaxComplete(performProtection);

function performProtection() {
	
	//remove html5 elements in desktop
	var removeElements = true;
	jQuery.each(plataformSupportList, function(key, value) {
		if (value) {
			removeElements = false;
		}
	});
	if (removeElements) {
		jQuery.each(attributeSupportList, function(key, value) {
			var elementType = '[' + key + ']';
			jQuery(elementType).each(function() {
				jQuery(this).removeAttr(key);
			});
		});
		
		jQuery.each(inputSupportList, function(key, value) {
			var elementType = '[type=' + key + ']';
			jQuery(elementType).each(function() {
				updateInputToTextType(this, key);
			});
		});
	}
	
	
	//remove html5 types
	jQuery.each(inputSupportList, function(key, value) {
		var elementType = '[type=' + key + ']';
		if (!value) {
			jQuery(elementType).each(function() {
				updateInputToTextType(this, key);
			});
		}
	});

	
	//remove html5 attributes
	jQuery.each(attributeSupportList, function(key, value) {
		var elementType = '[' + key + ']';
		if (!value) {
			jQuery(elementType).each(function() {
				jQuery(this).removeAttr(key);
			});
		}
	});
	
	
	//remove html5 validations
	jQuery.each(inputSupportList, function(key, value) {
		var elementType = '[type=' + key + ']';
		jQuery(elementType).each(function() {
			removeValidation(this);
		});
	});
	
	
	//initialize zipFields
	if (typeof countryZipCodeChangeList != 'undefined'){
		for (index = 0; index < countryZipCodeChangeList.length; ++index) {
		    var countryZipCode = countryZipCodeChangeList[index];
		    setZipCodeType(countryZipCode.country, countryZipCode.zip);
		}
	}
	
	
	//add Expected behavior
	addMaxLengthToNumber();
}

function updateInputToTextType(element, currentType) {

	if(jQuery.fn.jquery.indexOf('1.5')===0){
		var inputParent = jQuery(element).parent();
		var input = inputParent.html();
		var inputValue = jQuery(element).val();
		
		input = input.replace('type="' + currentType + '"', "type=\"text\"");
		inputParent.html(input);
		inputParent.children("input").val(inputValue);
	} else {
		jQuery(element).prop("type", "text");
	}
	
}

function removeValidation(element) {
	addNoValidateAttribute(element);
	preventInvalidEvent(element);
}

function addNoValidateAttribute(element) {
	var formElement = jQuery(element).closest("form");
	var attr = jQuery(formElement).attr("novalidate");

	if (typeof attr == typeof undefined || attr == false) {
		jQuery(formElement).attr("novalidate", "novalidate");
	}
}

function preventInvalidEvent(element) {
	jQuery(element).bind( "invalid", function(event) {
		event.preventDefault();
	});
}

function addMaxLengthToNumber() {
	jQuery('[type=number]').each(function() {
		var maxlength = jQuery(this).attr("maxlength");
		if (typeof maxlength == 'undefined' || maxlength <= 0) {
			return;
		}
		
		jQuery(this).keydown(function(e) {

			if (e.keyCode >= 65 && e.keyCode <= 90) {
				e.preventDefault();
			}
			
			if (jQuery(this).val().length < maxlength || jQuery.inArray(e.keyCode, [46, 8, 9, 27, 13]) !== -1 || (e.keyCode >= 35 && e.keyCode <= 39)) {
				return;
			} else {
				e.preventDefault();
			}

		});
		
	});
}

window.setZipCodeType=function(countrySelector, postalCodeField) {
	var countryList = ["0150", "0232", "0260", "0590", "0847", "0925"];
	if (jQuery.inArray(jQuery(countrySelector).val(), countryList) != -1) {
		changeInputTypeForSupportedMobile(postalCodeField, "text");
	} else {
		changeInputTypeForSupportedMobile(postalCodeField, "tel");
		jQuery(postalCodeField).css("-moz-appearance", "textfield" );
	}
}

window.changeInputTypeForSupportedMobile=function(input, newType){
	if( /Android|iPad/i.test(navigator.userAgent) ) {
		if(jQuery.fn.jquery.indexOf('1.5')===0){
			var inputId = input.replace('#', '');  
			var inputToChange = document.getElementById(inputId);
			inputToChange.type = newType;
		} else {
			jQuery(input).prop("type", newType);
		}
	}
}
/****************************************************************
* Hotel Search Results - LIST VIEW - search-list.js
*****************************************************************/

var SearchResultsPageList = (function ($) { // See also GLOBAL_SEARCH_RESULTS_PAGE_LIST alias below...

	"use strict"; // (ES5 - jshint.com :)
	/*jshint forin:true, noarg:true, noempty:true, eqeqeq:true, bitwise:true, strict:true,
	undef:true, unused:true, curly:true, browser:true, jquery:true, indent:4, maxerr:50 */
	/*exported GLOBAL_SEARCH_RESULTS_PAGE_LIST */
	/*global google, GoogleMaps*/

	var _private = { // Private Closure, changeable only via _public at runtime...

		// data...

		// dev testing...
		debug: true // Set to 'false' to suppress TRACE messages in console...
	};

	var _public  = { // Shared access, changeable at runtime...

		// entry points...
		onDocumentReady: {},

		// modules...

		// Console Debug Output.
		// Usage: SearchResultsPageList.TRACE('msg') === console.log('msg')
		TRACE: (_private.debug && window.console && window.console.log && window.console.log.bind) ? window.console.log.bind(window.console) : function () {}
	};

	// Main processing AFTER document is loaded and the DOM is ready.
	// Note: This is the same exact thing as $(document).ready(function() {}
	// Please refrain from adding any 'other' document.ready() calls.
	_public.onDocumentReady = $(function () {

		// Load all shared map markers for all hotels.
		loadMapMarkerData();

		// Show/Hide Hotel Details.
		bindHotelDetailsToggle();

		// Show/Hide Hotel Maps.
		bindHotelMapsToggle();
		
		// Bind Hotel Summary 'View More' Link...
		bindViewMoreSummaryLink();

		// Bind Hotel Details 'View More' Description Link...
		bindViewMoreDescLink();

	});

	// Load all shared map markers for all hotels.
	function loadMapMarkerData() {
		
		if ('undefined' === typeof SEARCH_MAPVIEW_MARKERS) {
			return;			
		}
		
		GoogleMaps.loadMapMarkerData(SEARCH_MAPVIEW_CENTER, SEARCH_MAPVIEW_MARKERS);
	}

	// Show/Hide Hotel Details.
	function bindHotelDetailsToggle() {
		$('#searchResultContainer').on('click', '.detailsBtn, .closeDetailsWell button.close',  function(e) {
			e.preventDefault();
			var $resRow = $(this).closest('.resRow');
			var mnemonic = $resRow.find('.selectedHotelCode').val();
			var $detailsTarget = $('#vhd-' + mnemonic);
			var $mapTarget = $('#map-' + mnemonic);

			// Toggle up/dn chevron icon...
			$resRow.find('.detailsBtn').toggleClass('on');
			if ($mapTarget.is(":visible")) {
				$(this).siblings('.mapsBtn').toggleClass('on');
			}

			// Only load once - hide/show after already loaded...
			if ($detailsTarget.children('div').length > 0) {

				// Toggle Details/Map - only show one at a time...
				if ($mapTarget.is(":visible")) {
					$mapTarget.slideToggle('slow', function() {
						$detailsTarget.slideToggle('slow');
					});
				} else {
					$detailsTarget.slideToggle('slow');
				}
			} else {

				// load the Hotel Details...
				var ajaxUrl = $('#vhd-ajax-' + mnemonic).val();
				$detailsTarget.load(ajaxUrl, function(/*response, status, xhr*/) {
					if ($mapTarget.is(":visible")) {
						$mapTarget.slideToggle('slow', function() {
							$detailsTarget.slideToggle('slow');
						});
					} else {
						$detailsTarget.slideToggle('slow');
					}
				});
			}

			// Force scroll position...
			$('html, body').animate({scrollTop: $resRow.offset().top-9}, 'slow');
		});
	}
	
	// Show/Hide Hotel Maps.
	function bindHotelMapsToggle() {
		$('#searchResultContainer').on('click', '.mapsBtn',  function(e) {
			e.preventDefault();
			var $resRow = $(this).closest('.resRow');
			var mnemonic = $resRow.find('.selectedHotelCode').val();
			var $detailsTarget = $('#vhd-' + mnemonic);
			var $mapTarget = $('#map-' + mnemonic);

			// Toggle up/dn chevron icon...
			$resRow.find('.mapsBtn').toggleClass('on');
			if ($detailsTarget.is(":visible")) {
				$(this).siblings('.detailsBtn').toggleClass('on');
			}

			// Only load once - hide/show after already loaded...
			if ($mapTarget.children().length > 0) {

				// Toggle Details/Map - only show one at a time...
				if ($detailsTarget.is(":visible")) {
					$detailsTarget.slideToggle('slow', function() {
						$mapTarget.slideToggle('slow');
					});
				} else {
					$mapTarget.slideToggle('slow');
				}
			} else {

				// Setup the new Map options...
				var coords = $(this).attr('name').split(',');
				var mapOptions = {
					mapTypeId : google.maps.MapTypeId.ROADMAP,
					center: new google.maps.LatLng(coords[0], coords[1]),
					scrollwheel: false,
					zoom: 15
				};

				// Toggle Details/Map - only show one at a time...
				if ($detailsTarget.is(":visible")) {
					$detailsTarget.slideToggle('slow', function() {
						// Create a new Map instance...
						$mapTarget.show();
						GoogleMaps.createInstance($mapTarget, coords[0], coords[1], mapOptions, mnemonic, "listview");
					});
				} else {
					// Create a new Map instance...
					$mapTarget.show();
					GoogleMaps.createInstance($mapTarget, coords[0], coords[1], mapOptions, mnemonic, "listview");
				}
			}

			// Force scroll position...
			$('html, body').animate({scrollTop: $resRow.offset().top-9}, 'slow');
		});
	}

	// Bind Hotel Summary 'View More' Link...
	function bindViewMoreSummaryLink() {
		$('#searchResultContainer').on('click', '.viewMoreSummaryLink', function(e) {
			e.preventDefault();
			
			var mnemonic = $(this).data("hotelMnemonic");
			
			$('#shortHotelDesc_' + mnemonic).css('display','none');
			$('#viewMoreHotelDesc_' + mnemonic).css('display','none');
			$('#hotelDesc_' + mnemonic).css('display','block');
		});
	}

	// Bind Hotel Details 'View More' Description Link...
	function bindViewMoreDescLink() {
		$('#searchResultContainer').on('click', '.viewMoreDescLink', function(e) {
			e.preventDefault();
			// Show/Hide Hotel Details 'View More'.
			$(this).hide();
			$(this).siblings('.lessDesc').hide();
			$(this).siblings('.viewMoreDesc').slideToggle('slow');
		});
	}

	// Return public methods.
	return _public;

}(window.jQuery));

// Alias as GLOBAL_*_* to protect namespace...
var GLOBAL_SEARCH_RESULTS_PAGE_LIST = SearchResultsPageList;

/* end of search-list.js */
